<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenLink AI Layer (OPAL) Functions (Tools) Playground</title>
    <link rel="icon" type="image/png" href="https://www.openlinksw.com/skin/bootstrap-2022/images/favicon.png">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "OpenLink AI Layer (OPAL) Functions (Tools) Playground",
      "description": "An immersive, interactive playground to accelerate developer onboarding. Go from zero to a fully authenticated API call interactions in seconds.",
      "datePublished": "2025-01-01",
      "author": {
        "@type": "Organization",
        "name": "OpenLink Software",
        "url": "https://www.openlinksw.com"
      },
      "publisher": {
        "@type": "Organization",
        "name": "OpenLink Software",
        "logo": {
          "@type": "ImageObject",
          "url": "https://www.openlinksw.com/skin/bootstrap-2022/images/favicon.png"
        }
      }
    }
    </script>
    <style>
        /* --- Reset & Global Styles --- */
        :root {
            --color-background: #121212;
            --color-surface: #1e1e1e;
            --color-primary: #4a90e2;
            --color-primary-dark: #3a7bc8;
            --color-secondary: #2a2a2a;
            --color-text: #e0e0e0;
            --color-text-muted: #888;
            --color-border: #333;
            --color-success: #28a745;
            --color-error: #dc3545;
            --color-get: #49cc90;
            --color-post: #61affe;
            --color-put: #fca130;
            --color-delete: #f93e3e;
            --font-family-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-family-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-family-sans);
            background-color: var(--color-background);
            color: var(--color-text);
            line-height: 1.6;
        }

        h1,
        h2,
        h3,
        h4 {
            line-height: 1.2;
            margin-bottom: 1rem;
            position: relative;
        }

        p {
            margin-bottom: 1rem;
            color: var(--color-text-muted);
        }

        a {
            color: var(--color-primary);
            text-decoration: none;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        /* --- Buttons --- */
        .btn {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-weight: 600;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: none;
            font-size: 1rem;
            margin-right: 0.5rem;
        }

        .btn:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: #fff;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--color-primary-dark);
        }

        .btn-secondary {
            background-color: transparent;
            color: var(--color-primary);
            border: 1px solid var(--color-primary);
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: var(--color-primary);
            color: #fff;
        }

        .btn-run {
            background-color: var(--color-success);
            color: #fff;
            font-weight: bold;
        }

        .btn-run:hover:not(:disabled) {
            opacity: 0.9;
        }

        .btn-remove-url {
            padding: 0.5rem 1rem;
            background-color: var(--color-error);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-remove-url:hover {
            opacity: 0.9;
        }

        .btn-remove-model {
            padding: 0.5rem 1rem;
            background-color: var(--color-error);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .btn-remove-model:hover {
            opacity: 0.9;
        }

        /* --- Inputs & Forms --- */
        .input-group {
            margin-bottom: 1rem;
            position: relative;
        }

        .api-key-toggle-vis {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            color: var(--color-text-muted);
            padding: 5px;
        }

        .api-key-toggle-vis svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            stroke-width: 1.5;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .api-key-toggle-vis:hover {
            color: var(--color-text);
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--color-text-muted);
        }

        .input-group input,
        .input-group textarea,
        .input-group select {
            width: 100%;
            padding: 0.75rem;
            background-color: var(--color-secondary);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            color: var(--color-text);
            font-size: 1rem;
            font-family: var(--font-family-sans);
        }

        .input-group input[readonly] {
            background-color: #2a2a2a;
            color: var(--color-text-muted);
            cursor: not-allowed;
        }

        .input-group input:focus,
        .input-group textarea:focus,
        .input-group select:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.5);
        }

        .input-group textarea {
            min-height: 150px;
            font-family: var(--font-family-mono);
            resize: vertical;
        }

        /* --- LLM Management Styles --- */
        .llm-list {
            background-color: var(--color-secondary);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .llm-list h5 {
            margin-bottom: 1rem;
            color: var(--color-text);
        }

        .llm-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background-color: var(--color-background);
            border: 1px solid var(--color-border);
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }

        .llm-item:last-child {
            margin-bottom: 0;
        }

        .llm-item-info {
            flex-grow: 1;
        }

        .llm-item-name {
            font-weight: 600;
            color: var(--color-text);
            font-family: var(--font-family-mono);
        }

        .llm-item-provider {
            font-size: 0.85rem;
            color: var(--color-text-muted);
            margin-top: 0.25rem;
        }

        .llm-form {
            background-color: var(--color-secondary);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 1.5rem;
        }

        .llm-form h5 {
            margin-bottom: 1rem;
            color: var(--color-text);
        }

        .llm-form-row {
            display: flex;
            gap: 1rem;
            align-items: flex-end;
        }

        .llm-form-row .input-group {
            flex: 1;
            margin-bottom: 0;
        }

        .llm-form-row .btn {
            flex-shrink: 0;
        }

        .llm-empty-state {
            text-align: center;
            padding: 2rem;
            color: var(--color-text-muted);
            font-style: italic;
        }

        /* --- Section 1: Hero --- */
        .hero {
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            background: linear-gradient(rgba(18, 18, 18, 0.8), rgba(18, 18, 18, 1)), url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100%" height="100%"><defs><pattern id="p" width="10" height="10" patternUnits="userSpaceOnUse"><circle cx="5" cy="5" r="0.5" fill="%232a2a2a"/></pattern></defs><rect width="100%" height="100%" fill="url(%23p)"/></svg>');
        }

        .hero-content {
            max-width: 800px;
        }

        .hero h1 {
            font-size: 3.5rem;
            margin-bottom: 1rem;
        }

        .hero p {
            font-size: 1.25rem;
            margin-bottom: 2rem;
            color: var(--color-text);
        }

        .hero-buttons .btn {
            margin: 0 0.5rem;
        }

        /* --- Section 2: Quick Start Guide --- */
        .quick-start {
            padding: 6rem 0;
        }

        .quick-start h2 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 4rem;
        }

        .timeline {
            position: relative;
            max-width: 960px;
            margin: 0 auto;
        }

        .timeline::after {
            content: '';
            position: absolute;
            width: 4px;
            background-color: var(--color-border);
            top: 0;
            bottom: 0;
            left: 50%;
            margin-left: -2px;
        }

        .timeline-item {
            padding: 1rem 3rem;
            position: relative;
            width: 50%;
        }

        .timeline-item::after {
            content: '';
            position: absolute;
            width: 25px;
            height: 25px;
            right: -12.5px;
            background-color: var(--color-background);
            border: 4px solid var(--color-primary);
            top: 25px;
            border-radius: 50%;
            z-index: 1;
        }

        .timeline-item.left {
            left: 0;
            padding-right: 50px;
        }

        .timeline-item.right {
            left: 50%;
            padding-left: 50px;
        }

        .timeline-item.right::after {
            left: -12.5px;
        }

        .timeline-content {
            padding: 1.5rem;
            background-color: var(--color-surface);
            border-radius: 8px;
            border: 1px solid var(--color-border);
        }

        .timeline-content h3 {
            color: var(--color-primary);
        }

        .response-viewer-wrapper {
            position: relative;
        }

        .btn-copy-content {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: var(--color-secondary);
            color: var(--color-text-muted);
            border: 1px solid var(--color-border);
            border-radius: 4px;
            padding: 0.2rem 0.5rem;
            font-size: 0.8rem;
            cursor: pointer;
            z-index: 10;
        }

        .btn-copy-content:hover {
            background-color: #333;
            color: var(--color-text);
        }

        .response-viewer {
            margin-top: 1rem;
            background-color: var(--color-secondary);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 1rem;
            font-family: var(--font-family-mono);
            white-space: pre-wrap;
            word-break: break-all;
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
            resize: vertical;
            color: var(--color-text-muted);
        }

        .response-viewer.success {
            color: var(--color-text);
            border-color: var(--color-success);
        }

        .response-viewer.error {
            color: var(--color-error);
            border-color: var(--color-error);
        }

        .response-viewer.chat-log {
            max-height: 500px;
            font-family: var(--font-family-sans);
            white-space: normal;
        }

        .chat-log .message {
            position: relative;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--color-border);
        }

        .chat-log .message .btn-copy-content {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .chat-log .message:hover .btn-copy-content {
            opacity: 1;
        }


        .chat-log .message:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .chat-log .message-sender {
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: var(--color-primary);
        }

        .chat-log .message-sender.user {
            color: var(--color-success);
        }

        .chat-log .message-content {
            padding-right: 4rem;
        }

        .chat-log .message-content p {
            margin-bottom: 0.5em;
            color: var(--color-text);
        }

        .chat-log .message-content pre {
            background-color: var(--color-background);
            padding: 0.75rem;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-all;
            font-family: var(--font-family-mono);
        }

        .chat-log .message-content code {
            background-color: var(--color-background);
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: var(--font-family-mono);
        }

        .code-snippet {
            background-color: var(--color-secondary);
            padding: 1rem;
            border-radius: 6px;
            font-family: var(--font-family-mono);
            white-space: pre-wrap;
            word-break: break-all;
            color: var(--color-text-muted);
            border: 1px solid var(--color-border);
        }

        .state-display {
            background: var(--color-secondary);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-family: var(--font-family-mono);
            color: var(--color-success);
            margin-top: 1rem;
            word-break: break-all;
        }

        .state-display strong {
            color: var(--color-text-muted);
        }

        /* --- Agent Creation Form Specifics --- */
        #path-create .input-group p {
            font-size: 0.9rem;
            margin-top: 0.25rem;
            margin-bottom: 1rem;
        }

        #path-create .input-group textarea {
            min-height: 250px;
        }

        /* --- Drop Zone Styles --- */
        .drop-zone {
            position: relative;
            border: 2px dashed var(--color-border);
            border-radius: 6px;
            transition: all 0.2s ease-in-out;
        }

        .drop-zone.drag-over {
            border-color: var(--color-primary);
            background-color: rgba(74, 144, 226, 0.1);
        }

        .drop-zone textarea {
            border: none;
            background-color: transparent;
        }

        .drop-zone textarea:focus {
            box-shadow: none;
        }

        .drop-zone .drop-zone-prompt {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            pointer-events: none;
            color: var(--color-text-muted);
            transition: opacity 0.2s ease-in-out;
        }

        .drop-zone .drop-zone-prompt p {
            margin-bottom: 0.5rem;
        }

        .drop-zone .drop-zone-prompt .btn {
            pointer-events: all;
        }

        .drop-zone.has-content .drop-zone-prompt {
            opacity: 0;
        }

        #markdown-file-input {
            display: none;
        }

        /* --- Section 3: API Explorer --- */
        .api-explorer {
            padding: 6rem 0;
        }

        .api-explorer-layout {
            display: flex;
            gap: 2rem;
        }

        .api-sidebar {
            width: 250px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            align-self: flex-start;
        }

        .api-sidebar h3 {
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--color-border);
            padding-bottom: 0.5rem;
        }

        .api-sidebar ul {
            list-style: none;
        }

        .api-sidebar li a {
            display: block;
            padding: 0.5rem 0;
            color: var(--color-text-muted);
            transition: color 0.2s;
        }

        .api-sidebar li a:hover,
        .api-sidebar li a.active {
            color: var(--color-primary);
        }

        .api-content {
            flex-grow: 1;
            min-width: 0;
        }

        .config-banner {
            background-color: var(--color-surface);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            border: 1px solid var(--color-border);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }

        .config-banner .input-group {
            margin-bottom: 0;
        }

        .config-banner .full-width {
            grid-column: 1 / -1;
        }

        .api-category h2 {
            font-size: 2rem;
            margin-top: 2rem;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--color-border);
            text-transform: capitalize;
        }

        .api-category:first-of-type h2 {
            margin-top: 0;
        }

        .endpoint-card {
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            margin-bottom: 1.5rem;
            overflow: hidden;
        }

        .endpoint-header {
            display: flex;
            align-items: center;
            padding: 1rem 1.5rem;
            cursor: pointer;
            background-color: var(--color-secondary);
        }

        .endpoint-header:hover {
            background-color: #333;
        }

        .method-badge {
            font-family: var(--font-family-mono);
            font-weight: bold;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            margin-right: 1rem;
            color: #fff;
            font-size: 0.9rem;
        }

        .method-badge.get {
            background-color: var(--color-get);
        }

        .method-badge.post {
            background-color: var(--color-post);
        }

        .method-badge.put {
            background-color: var(--color-put);
        }

        .method-badge.delete {
            background-color: var(--color-delete);
        }

        .endpoint-path {
            font-family: var(--font-family-mono);
            font-size: 1.1rem;
            flex-grow: 1;
        }

        .endpoint-summary {
            color: var(--color-text-muted);
            font-size: 0.9rem;
            margin-left: 1rem;
            text-align: right;
            flex-shrink: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .endpoint-body {
            display: none;
            padding: 1.5rem;
        }

        .endpoint-card.open .endpoint-body {
            display: block;
        }

        .endpoint-section {
            margin-top: 1.5rem;
        }

        .endpoint-section h4 {
            color: var(--color-text-muted);
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--color-border);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }

        .param-table {
            width: 100%;
        }

        .param-table .input-group {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .param-table label {
            flex-basis: 200px;
            flex-shrink: 0;
            margin-bottom: 0;
            text-align: right;
        }

        .param-table label .param-type {
            display: block;
            font-weight: normal;
            font-size: 0.8rem;
            font-family: var(--font-family-mono);
        }

        .param-table input {
            flex-grow: 1;
        }

        .required-dot {
            color: var(--color-error);
        }

        .code-tabs {
            display: flex;
            border-bottom: 1px solid var(--color-border);
            margin-bottom: -1px;
        }

        .code-tab {
            padding: 0.5rem 1rem;
            cursor: pointer;
            color: var(--color-text-muted);
            border: 1px solid transparent;
            border-bottom: none;
        }

        .code-tab.active {
            color: var(--color-primary);
            background-color: var(--color-secondary);
            border-color: var(--color-border);
            border-radius: 6px 6px 0 0;
        }

        .code-snippet-container .code-snippet {
            border-top-left-radius: 0;
        }

        .code-snippet-container .code-snippet:not(.active) {
            display: none;
        }

        .try-it-live {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .try-it-live .btn-run {
            padding: 0.75rem 2rem;
        }

        .try-it-live .response-viewer {
            flex-grow: 1;
            margin-top: 0;
        }

        /* --- Function Calling --- */
        .function-selector {
            background-color: var(--color-secondary);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .function-selector h5 {
            margin-top: 0;
            margin-bottom: 0.75rem;
            color: var(--color-text-muted);
        }

        .function-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .function-item {
            display: flex;
            align-items: center;
        }

        .function-item input {
            margin-right: 0.5rem;
        }

        .function-item label {
            font-family: var(--font-family-mono);
            word-break: break-all;
        }


        /* --- Copy Link Icon & Tooltip --- */
        .copy-link-icon {
            position: absolute;
            left: -28px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            color: var(--color-text-muted);
        }

        h2:hover .copy-link-icon,
        h3:hover .copy-link-icon,
        .endpoint-header:hover .copy-link-icon {
            opacity: 1;
        }

        .copy-link-icon svg {
            width: 20px;
            height: 20px;
        }

        .copy-link-icon:hover {
            color: var(--color-primary);
        }

        .copy-tooltip {
            position: absolute;
            background-color: var(--color-success);
            color: #fff;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            top: 50%;
            left: -90px;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .copy-tooltip.visible {
            opacity: 1;
        }

        /* --- Footer --- */
        footer {
            background-color: var(--color-surface);
            color: var(--color-text-muted);
            padding: 2rem 0;
            margin-top: 4rem;
            border-top: 1px solid var(--color-border);
            font-size: 0.9rem;
        }

        .footer-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .footer-links {
            display: flex;
            gap: 1.5rem;
        }

        .footer-links a {
            color: var(--color-text-muted);
            transition: color 0.2s;
        }

        .footer-links a:hover {
            color: var(--color-primary);
        }

        /* --- Responsive Styles --- */
        @media (max-width: 992px) {
            .hero h1 {
                font-size: 2.5rem;
            }

            .container {
                padding: 0 1rem;
            }

            .timeline::after {
                left: 31px;
            }

            .timeline-item {
                width: 100%;
                padding-left: 70px;
                padding-right: 25px;
            }

            .timeline-item.left,
            .timeline-item.right {
                left: 0;
            }

            .timeline-item::after,
            .timeline-item.right::after {
                left: 15px;
            }

            .config-banner {
                grid-template-columns: 1fr;
            }

            .api-explorer-layout {
                flex-direction: column;
            }

            .api-sidebar {
                width: 100%;
                position: static;
                align-self: initial;
            }
        }
    </style>
</head>

<body>

    <!-- ================================================== -->
    <!-- SECTION 1: HERO INTRODUCTION                       -->
    <!-- ================================================== -->
    <section class="hero">
        <div class="hero-content">
            <h1>OpenLink AI Layer (OPAL) Functions (Tools) Playground</h1>
            <p>An immersive, interactive playground to accelerate developer onboarding. Go from zero to a fully
                authenticated API call interactions in seconds.</p>
            <div class="hero-buttons">
                <a href="#quick-start" class="btn btn-primary">Start the Developer Guide</a>
                <a href="#api-explorer" class="btn btn-secondary">Jump to API Explorer</a>
            </div>
        </div>
    </section>

    <main class="container">
        <!-- ================================================== -->
        <!-- SECTION 2: INTERACTIVE QUICK START GUIDE           -->
        <!-- ================================================== -->
        <section id="quick-start" class="quick-start">
            <h2 id="interactive-quick-start">Interactive Quick Start</h2>
            <div class="timeline">
                <!-- Step 1 -->
                <div class="timeline-item left">
                    <div class="timeline-content" id="qs-step-1-configure-endpoint">
                        <h3>Step 1: Configure Your Endpoint</h3>
                        <p>You can manually enter the endpoint URL below, or load it automatically from one or more
                            OpenAPI specification files.</p>
                        <div class="input-group">
                            <label for="openapi-spec-urls">Load from OpenAPI Spec URL(s) (Optional)</label>
                            <div id="openapi-urls-container">
                                <!-- This will be populated by JavaScript -->
                            </div>
                            <button id="add-url-btn" class="btn btn-secondary" style="margin-top: 0.5rem;">Add
                                URL</button>
                        </div>
                        <button id="load-spec-btn" class="btn btn-primary">Load Spec(s)</button>
                        <p id="spec-status-msg" style="font-size: 0.9rem; margin-top: 0.5rem; min-height: 1.2em;"></p>
                        <div class="input-group">
                            <label for="qs-endpoint-url" id="qs-endpoint-url-label">Service Endpoint URL</label>
                            <input type="text" id="qs-endpoint-url" class="global-state-input"
                                data-state-key="endpointUrl" placeholder="https://your-api-server.com/api">
                        </div>
                    </div>
                </div>
                <!-- Step 2 -->
                <div class="timeline-item right">
                    <div class="timeline-content" id="qs-step-2-authenticate">
                        <h3>Step 2: Authenticate & Create Session</h3>
                        <p>Choose your authentication method to establish a new session.</p>
                        <div class="auth-choice" style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                            <div>
                                <input type="radio" id="auth-choice-bearer" name="auth-type" value="bearer" checked>
                                <label for="auth-choice-bearer">
                                    <a id="bearer-token-main-link" href="#" target="_blank"
                                        rel="noopener noreferrer">Bearer Token</a>
                                </label>
                            </div>
                            <div>
                                <input type="radio" id="auth-choice-oauth" name="auth-type" value="oauth">
                                <label for="auth-choice-oauth">OAuth 2.1</label>
                            </div>
                        </div>

                        <div id="auth-bearer-view">
                            <div class="input-group">
                                <label for="qs-api-key">API Key (Bearer Token)</label>
                                <input type="password" id="qs-api-key" class="global-state-input"
                                    data-state-key="apiKey" placeholder="Paste your API key here">
                                <button class="api-key-toggle-vis" title="Toggle API Key Visibility"></button>
                            </div>
                            <p id="bearer-token-link-container" style="font-size: 0.9rem; margin-top: -0.5rem;"></p>
                            <button id="qs-auth-and-create" class="btn btn-primary">Create Session</button>
                        </div>

                        <div id="auth-oauth-view" style="display: none;">
                            <div class="input-group" id="oauth-client-id-group" style="display: none;">
                                <label for="oauth-client-id">Client ID</label>
                                <input type="text" id="oauth-client-id" class="global-state-input"
                                    data-state-key="oauthClientId" placeholder="Your OAuth Client ID">
                            </div>
                            <button id="oauth-login-btn" class="btn btn-primary">Login & Authorize</button>
                            <button id="oauth-logout-btn" class="btn btn-secondary" style="display: none;">Logout /
                                Reset</button>
                            <p id="oauth-status-msg" style="font-size: 0.9rem; margin-top: 0.5rem; min-height: 1.2em;">
                            </p>
                        </div>

                        <pre id="qs-auth-response"
                            class="response-viewer">Session will be created upon authentication...</pre>
                        <div id="qs-chat-id-display" class="state-display" style="display: none;">
                            <strong>Session ID:</strong> <span id="qs-chat-id-value"></span>
                        </div>
                    </div>
                </div>
                <!-- Step 3 -->
                <div class="timeline-item left">
                    <div class="timeline-content" id="qs-step-3-list-resources">
                        <h3>Step 3: List Available Functions & Agents</h3>
                        <p>Retrieve the list of available functions and pre-configured agents for your session.</p>
                        <button id="qs-run-list-resources" class="btn btn-primary">List Functions & Agents</button>
                        <pre id="qs-list-response" class="response-viewer">Response will appear here...</pre>
                    </div>
                </div>
                <!-- Step 4 -->
                <div class="timeline-item right">
                    <div class="timeline-content" id="qs-step-4-interact">
                        <h3>Step 4: Configure Session</h3>
                        <p>Choose your method: bind functions to your session, instantiate an existing agent, or create
                            a new one.</p>

                        <div class="session-choice"
                            style="display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 1rem;">
                            <div style="display: flex; align-items: center;">
                                <input type="radio" id="choice-llms" name="session-type" value="llms"
                                    style="margin-right: 0.5rem;">
                                <label for="choice-llms">Manage LLMs</label>
                            </div>
                            <div style="display: flex; align-items: center;">
                                <input type="radio" id="choice-functions" name="session-type" value="functions" checked
                                    style="margin-right: 0.5rem;">
                                <label for="choice-functions">Bind Functions</label>
                            </div>
                            <div style="display: flex; align-items: center;">
                                <input type="radio" id="choice-instantiate" name="session-type" value="instantiate"
                                    style="margin-right: 0.5rem;">
                                <label for="choice-instantiate">Instantiate Agent</label>
                            </div>
                            <div style="display: flex; align-items: center;">
                                <input type="radio" id="choice-create" name="session-type" value="create"
                                    style="margin-right: 0.5rem;">
                                <label for="choice-create">Create New Agent</label>
                            </div>
                        </div>

                        <!-- Path 1: Bind Functions -->
                        <div id="path-functions">
                            <div id="qs-function-selector-container">
                                <p style="color: var(--color-text-muted); font-style: italic;">Run Step 3 to load
                                    functions.</p>
                            </div>
                            <button id="qs-run-bind-functions" class="btn btn-primary">Bind Selected Functions to
                                Session</button>
                        </div>

                        <!-- Path 2: Instantiate Agent -->
                        <div id="path-instantiate" style="display:none;">
                            <div id="agent-creation-block">
                                <div class="input-group">
                                    <label for="qs-agent-select">Select an Agent</label>
                                    <select id="qs-agent-select">
                                        <option>Run Step 3 to load agents...</option>
                                    </select>
                                </div>
                                <div class="input-group">
                                    <label for="qs-agent-model-select">Model</label>
                                    <select id="qs-agent-model-select" class="global-state-input"
                                        data-state-key="model">
                                        <option>Run Step 3 to populate models...</option>
                                    </select>
                                </div>
                                <div class="input-group">
                                    <label for="qs-agent-title-input">Session Title (Optional)</label>
                                    <input type="text" id="qs-agent-title-input"
                                        placeholder="e.g., My Virtuoso Support Chat">
                                </div>
                                <button id="qs-run-instantiate-agent" class="btn btn-primary">Instantiate Agent</button>
                            </div>

                            <div id="agent-interaction-block" style="display: none;">
                                <h4 style="margin-top:0;">Chat with <strong id="active-agent-name"
                                        style="color: var(--color-primary);"></strong></h4>
                                <div class="input-group">
                                    <label for="qs-agent-model-key">Model API Key (Optional Override)</label>
                                    <input type="password" id="qs-agent-model-key" class="global-state-input"
                                        data-state-key="modelApiKeyOverride"
                                        placeholder="Leave blank to use system default">
                                    <button class="api-key-toggle-vis" title="Toggle API Key Visibility">
                                    </button>
                                </div>
                                <div class="input-group">
                                    <label for="qs-agent-chat-input">Your Message</label>
                                    <div style="display: flex; gap: 0.5rem;">
                                        <input type="text" id="qs-agent-chat-input"
                                            placeholder="Ask the agent a follow-up question..." style="flex: 1;">
                                        <button id="qs-agent-chat-send-btn" class="btn btn-secondary"
                                            style="flex-shrink: 0;">Send</button>
                                    </div>
                                </div>
                                <button id="qs-new-agent-session" class="btn btn-secondary">Start New Session</button>
                            </div>
                        </div>


                        <!-- Path 3: Create Agent -->
                        <div id="path-create" style="display:none;">
                            <div class="input-group">
                                <label for="qs-agent-dav-url">WebDAV Save URL</label>
                                <input type="text" id="qs-agent-dav-url"
                                    value="https://linkeddata.uriburner.com/DAV/VAD/personal_assistant/json/">
                                <p>The base URL of the WebDAV folder where the agent's .json file will be saved.</p>
                            </div>
                            <div class="input-group">
                                <label for="qs-agent-id">Agent ID</label>
                                <input type="text" id="qs-agent-id">
                                <p>A short, unique name. The prefix `system-` will be added automatically.
                                </p>
                            </div>
                            <div class="input-group">
                                <label for="qs-agent-title">Agent Title</label>
                                <input type="text" id="qs-agent-title">
                            </div>
                            <div class="input-group">
                                <label for="qs-agent-version">Agent Version</label>
                                <input type="text" id="qs-agent-version">
                            </div>
                            <div class="input-group">
                                <label for="qs-agent-creation-date">Creation Date</label>
                                <input type="text" id="qs-agent-creation-date" readonly>
                            </div>
                            <div class="input-group">
                                <label for="qs-agent-model">Base Model</label>
                                <select id="qs-agent-model">
                                    <option>Run Step 3 to load models...</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label for="qs-agent-prompt">System Prompt (Configuration in Markdown)</label>
                                <div class="response-viewer-wrapper">
                                    <div id="markdown-drop-zone" class="drop-zone">
                                        <textarea id="qs-agent-prompt"
                                            placeholder="You are a helpful assistant that specializes in..."></textarea>
                                        <div class="drop-zone-prompt">
                                            <p>Drag & drop a .md file here, or</p>
                                            <label for="markdown-file-input" class="btn btn-secondary">Click to
                                                Upload</label>
                                            <input type="file" id="markdown-file-input" accept=".md,.txt,text/markdown">
                                        </div>
                                    </div>
                                    <button class="btn-copy-content" data-target-id="qs-agent-prompt"
                                        title="Copy Prompt">Copy</button>
                                </div>
                            </div>
                            <div id="qs-agent-function-selector-container">
                                <p style="color: var(--color-text-muted); font-style: italic;">Run Step 3 to load
                                    functions.</p>
                            </div>
                            <button id="qs-run-save-agent" class="btn btn-primary">Save Agent Configuration</button>
                        </div>

                        <!-- Path 4: LLM Management -->
                        <div id="path-llms" style="display:none;">
                            <div class="input-group">
                                <label for="llm-provider-select">Select LLM Provider</label>
                                <select id="llm-provider-select">
                                    <option value="">Loading providers...</option>
                                </select>
                            </div>
                            <div id="llm-provider-view">
                                <p
                                    style="color: var(--color-text-muted); font-style: italic; text-align: center; padding: 2rem;">
                                    Select a provider to manage LLMs
                                </p>
                            </div>
                        </div>

                        <div class="response-viewer-wrapper">
                            <div id="qs-config-response" class="response-viewer">Response will appear here...</div>
                        </div>
                    </div>
                </div>
                <!-- Step 5 -->
                <div class="timeline-item left">
                    <div class="timeline-content" id="qs-step-5-modify-session">
                        <h3>Step 5: Modify Session Settings</h3>
                        <p>Now, let's customize our new session by changing its title and model, overwriting the
                            defaults.</p>
                        <div class="input-group">
                            <label for="qs-update-title">New Title</label>
                            <input type="text" id="qs-update-title" class="global-state-input" data-state-key="title">
                        </div>
                        <div class="input-group">
                            <label for="qs-update-model">New Model</label>
                            <select id="qs-update-model" class="global-state-input" data-state-key="model">
                                <option>Run Step 3 to populate models...</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label for="qs-update-top-p">Top P</label>
                            <input type="number" id="qs-update-top-p" min="0" max="1" step="0.1"
                                class="global-state-input" data-state-key="top_p">
                        </div>
                        <div class="input-group">
                            <label for="qs-update-temperature">Temperature</label>
                            <input type="number" id="qs-update-temperature" min="0" max="2" step="0.1"
                                class="global-state-input" data-state-key="temperature">
                        </div>
                        <div class="input-group">
                            <label for="qs-update-api-timeout">API Timeout (seconds)</label>
                            <input type="number" id="qs-update-api-timeout" min="1" step="1" class="global-state-input"
                                data-state-key="apiTimeoutSeconds">
                        </div>
                        <div class="input-group">
                            <label for="qs-update-model-key">Model API Key (Optional Override)</label>
                            <input type="password" id="qs-update-model-key" class="global-state-input"
                                data-state-key="modelApiKeyOverride" placeholder="Leave blank to use system default">
                            <button class="api-key-toggle-vis" title="Toggle API Key Visibility">
                            </button>
                        </div>
                        <button id="qs-run-update-topic" class="btn btn-primary">Update Session</button>
                        <pre id="qs-update-topic-response" class="response-viewer">Response will appear here...</pre>
                    </div>
                </div>
                <!-- Step 6 -->
                <div class="timeline-item right">
                    <div class="timeline-content" id="qs-step-6-ask-question">
                        <h3>Step 6: Ask a Question</h3>
                        <p>With our session configured, we can interact with it. Your `Session ID` and any selected
                            functions are automatically included in the request.</p>
                        <div class="input-group">
                            <label for="qs-question">Your Question</label>
                            <input type="text" id="qs-question" class="global-state-input" data-state-key="question">
                        </div>
                        <button id="qs-run-chat-completion" class="btn btn-primary">Send Question</button>
                        <div class="response-viewer-wrapper">
                            <pre id="qs-chat-completion-response"
                                class="response-viewer">Response will appear here...</pre>
                            <button class="btn-copy-content" data-target-id="qs-chat-completion-response"
                                title="Copy Response">Copy</button>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- ================================================== -->
        <!-- SECTION 3: INTERACTIVE API EXPLORER                -->
        <!-- ================================================== -->
        <section id="api-explorer" class="api-explorer">
            <h2 id="interactive-api-explorer" style="text-align: center; font-size: 2.5rem; margin-bottom: 4rem;">
                Interactive API Explorer</h2>
            <div class="config-banner">
                <div class="input-group full-width">
                    <label for="explorer-endpoint-url">Service Endpoint URL</label>
                    <input type="text" id="explorer-endpoint-url" class="global-state-input"
                        data-state-key="endpointUrl">
                </div>
                <div class="input-group">
                    <label for="explorer-api-key">API Key (Bearer Token)</label>
                    <input type="password" id="explorer-api-key" class="global-state-input" data-state-key="apiKey">
                    <button class="api-key-toggle-vis" title="Toggle API Key Visibility">
                    </button>
                </div>
                <div class="input-group">
                    <label for="explorer-chat-id">Active Chat ID</label>
                    <input type="text" id="explorer-chat-id" class="global-state-input" data-state-key="chatId">
                </div>
                <div class="input-group">
                    <label for="explorer-api-timeout">API Timeout (seconds)</label>
                    <input type="number" id="explorer-api-timeout" min="1" step="1" class="global-state-input"
                        data-state-key="apiTimeoutSeconds">
                </div>
            </div>
            <div class="api-explorer-layout">
                <aside class="api-sidebar" id="api-sidebar-nav">
                    <h3 id="api-categories">API Categories</h3>
                    <ul id="sidebar-links">
                    </ul>
                </aside>
                <div class="api-content" id="api-content-main">
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container footer-content">
            <div class="copyright">
                &copy; 2025 <a href="https://www.openlinksw.com">OpenLink Software</a>
            </div>
            <div class="footer-links">
                <strong>Solutions:</strong>
                <a href="https://opal.openlinksw.com">OPAL</a>
                <a href="https://virtuoso.openlinksw.com">Virtuoso</a>
                <strong>Alt. Reps:</strong>
                <a href="https://www.openlinksw.com/data/html/?a=rss">RSS</a>
                <a href="https://www.openlinksw.com/data/html/?a=atom">Atom</a>
            </div>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            /**
             * Main application object to encapsulate state, UI, API logic, and event handlers.
             */
            const App = {
                // --- STATE MANAGEMENT ---
                state: {
                    endpointUrl: 'https://linkeddata.uriburner.com/chat/api',
                    apiKey: '',
                    chatId: '',
                    isApiKeyVisible: false,
                    model: 'gpt-4o-mini',
                    title: "My Custom Chat",
                    question: "Execute `select now()`",
                    top_p: 0.5,
                    temperature: 0.5,
                    apiTimeoutSeconds: 30,
                    sessionFunctions: [],
                    modelApiKeyOverride: '',
                    authMethod: 'bearer',
                    oauthClientId: '',
                    openApiUrls: [],
                    openApiSpec: null,
                    oauthEndpoints: null,
                    isAgentSession: false,
                    currentAgent: null,
                    availableFunctions: [],
                    availableAgents: [],
                    currentSessionTools: [],
                    lastChatCompletionBody: null,
                    llmProviders: {},
                    currentAbortController: null,
                    currentAbortTimeout: null,
                    defaultAgentTemplate: `# Description

**Name:** my-new-agent
**Name:** Basic OPAL Agent
**Version:** 1.0.0
**Created:** 2025-09-30

## Features

- **Multi-Query Execution:** Capable of executing SQL, SPARQL, SPASQL, and GraphQL queries.
- **Ontology-Aware SPARQL:** Uses shared ontologies to inform the construction of SPARQL queries for enhanced accuracy.
- **Data Source Exploration:** Can explore target data sources to identify entity types and their prevalence.

### Functions

- **Description:** A universal tool for executing database and graph queries.
- **List:**
  - **name:** \`Query.execute\`
  - **signature:** \`(query_language, query_string, endpoint_url)\`

### Fine-tuning

#### Query Processing Features

##### Predefined Prompts

- **hint:** Use this when the user asks to explore, discover, or get a summary of the types of data in a SPARQL endpoint.
  **prompt:** Explore the data source and show me the types of entities it contains.
  **response:**
  \`\`\`sparql
    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

    SELECT ?type (COUNT(?entity) AS ?count) (SAMPLE(?entity) AS ?sampleEntity)
    WHERE {
    ?entity rdf:type ?type .
    }
    GROUP BY ?type
    ORDER BY DESC(?count)
  \`\`\`

## Commands

- **Prefix:** \`/\`
- **Available Commands:**
  - \`/help\`: Provides help for common issues or using the bot.
  - \`/query\`: Assists with formulating SPARQL-within-SQL queries.
  - \`/config\`: Guides users through driver configuration.
  - \`/troubleshoot\`: Helps troubleshoot connection or driver issues.
  - \`/limit\`: Sets the SPARQL query result set limit. Default value: 10.

## Rules

- Prioritize accuracy and directness in query results.
- When asked to explore a SPARQL endpoint, use the predefined exploration query.
- Inform the user if a query language is not supported or if a query fails to execute.


## Preferences

- **Interaction Style:** Friendly and professional
- **Knowledge Depth:** Deep and comprehensive
- **Response Speed:** Fast but accurate

## Initialization

Upon activation, the agent greets the user and awaits further instructions. If preferences are invalid or empty, the agent will guide users through a configuration process and adjust responses accordingly.
`
                },

                // --- INITIALIZATION ---
                init() {
                    const persistedEndpointUrl = sessionStorage.getItem('opal.endpointUrl');
                    if (persistedEndpointUrl) {
                        this.state.endpointUrl = persistedEndpointUrl;
                    }
                    if (this.state.openApiUrls.length === 0) {
                        this.state.openApiUrls = this.generateDefaultOpenApiUrls();
                    }
                    this.state.openApiSpec = this.getDefaultOpenApiSpec();
                    this.cacheDOMElements();
                    this.bindEventListeners();
                    this.ui.renderApiExplorer();
                    this.ui.renderOpenApiUrlInputs();
                    this.ui.initializeApiKeyVisibilityToggle();
                    this.ui.initializeLinkableHeaders();
                    this.ui.updateAllStateInputs();
                    this.ui.updateBearerTokenLink();
                    this.handlers.handleOAuthCallback();
                },

                cacheDOMElements() {
                    this.dom = {
                        qs: {
                            loadSpecBtn: document.getElementById('load-spec-btn'),
                            addUrlBtn: document.getElementById('add-url-btn'),
                            openapiUrlsContainer: document.getElementById('openapi-urls-container'),
                            authAndCreateBtn: document.getElementById('qs-auth-and-create'),
                            authResponseEl: document.getElementById('qs-auth-response'),
                            chatIdDisplay: document.getElementById('qs-chat-id-display'),
                            chatIdValue: document.getElementById('qs-chat-id-value'),
                            runListResourcesBtn: document.getElementById('qs-run-list-resources'),
                            listResponseEl: document.getElementById('qs-list-response'),
                            runBindFunctionsBtn: document.getElementById('qs-run-bind-functions'),
                            runInstantiateAgentBtn: document.getElementById('qs-run-instantiate-agent'),
                            configResponseEl: document.getElementById('qs-config-response'),
                            runSaveAgentBtn: document.getElementById('qs-run-save-agent'),
                            runUpdateTopicBtn: document.getElementById('qs-run-update-topic'),
                            updateTopicResponseEl: document.getElementById('qs-update-topic-response'),
                            runChatCompletionBtn: document.getElementById('qs-run-chat-completion'),
                            chatCompletionResponseEl: document.getElementById('qs-chat-completion-response'),
                            oauthLoginBtn: document.getElementById('oauth-login-btn'),
                            oauthLogoutBtn: document.getElementById('oauth-logout-btn'),
                            oauthStatusMsg: document.getElementById('oauth-status-msg'),
                            oauthClientIdGroup: document.getElementById('oauth-client-id-group'),
                            apiKeyInput: document.getElementById('qs-api-key'),
                            explorerApiKeyInput: document.getElementById('explorer-api-key'),
                            bearerTokenLinkContainer: document.getElementById('bearer-token-link-container'),
                            bearerTokenMainLink: document.getElementById('bearer-token-main-link'),
                            agentCreationBlock: document.getElementById('agent-creation-block'),
                            agentInteractionBlock: document.getElementById('agent-interaction-block'),
                            activeAgentName: document.getElementById('active-agent-name'),
                            agentChatInput: document.getElementById('qs-agent-chat-input'),
                            agentChatSendBtn: document.getElementById('qs-agent-chat-send-btn'),
                            newAgentSessionBtn: document.getElementById('qs-new-agent-session'),
                            questionInput: document.getElementById('qs-question'),
                        },
                        apiExplorer: {
                            sidebar: document.getElementById('sidebar-links'),
                            content: document.getElementById('api-content-main'),
                        }
                    };
                },

                bindEventListeners() {
                    document.body.addEventListener('input', (e) => {
                        if (e.target.classList.contains('global-state-input')) {
                            const key = e.target.dataset.stateKey;
                            const value = e.target.type === 'number' ? parseFloat(e.target.value) : e.target.value;
                            this.updateState(key, value, e.target);
                        }
                    });

                    this.dom.qs.loadSpecBtn.addEventListener('click', () => this.handlers.handleLoadOpenApiSpec());
                    this.dom.qs.addUrlBtn.addEventListener('click', () => this.handlers.handleOpenApiUrlInteraction({ type: 'add' }));
                    this.dom.qs.openapiUrlsContainer.addEventListener('click', (e) => this.handlers.handleOpenApiUrlInteraction(e));
                    this.dom.qs.openapiUrlsContainer.addEventListener('input', (e) => this.handlers.handleOpenApiUrlInteraction(e));

                    this.dom.qs.authAndCreateBtn.addEventListener('click', (e) => this.handlers.handleAuthAndCreate(e.target));
                    this.dom.qs.runListResourcesBtn.addEventListener('click', (e) => this.handlers.handleListResources(e.target));
                    this.dom.qs.runBindFunctionsBtn.addEventListener('click', (e) => this.handlers.handleBindFunctions(e.target));
                    this.dom.qs.runInstantiateAgentBtn.addEventListener('click', (e) => this.handlers.handleInstantiateAgent(e.target));
                    this.dom.qs.runUpdateTopicBtn.addEventListener('click', (e) => this.handlers.handleUpdateTopic(e.target));
                    this.dom.qs.runChatCompletionBtn.addEventListener('click', (e) => this.handlers.handleChatCompletion(e.target));
                    this.dom.qs.runSaveAgentBtn.addEventListener('click', (e) => this.handlers.handleSaveAgent(e.target));
                    this.dom.qs.oauthLoginBtn.addEventListener('click', (e) => this.handlers.handleOAuthLogin(e.target));
                    this.dom.qs.oauthLogoutBtn.addEventListener('click', () => this.handlers.resetAuthenticationState());

                    this.dom.qs.agentChatSendBtn.addEventListener('click', (e) => this.handlers.handleAgentChatCompletion(e.target));
                    this.dom.qs.agentChatInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.handlers.handleAgentChatCompletion(this.dom.qs.agentChatSendBtn);
                        }
                    });
                    this.dom.qs.newAgentSessionBtn.addEventListener('click', () => {
                        if (confirm('This will end the current session and start a new one. Continue?')) {
                            this.ui.switchToAgentSelectionView();
                        }
                    });

                    this.dom.qs.questionInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.dom.qs.runChatCompletionBtn.click();
                        }
                    });

                    this.ui.initializeAuthMethodToggle();
                    this.ui.initializeStep4Choice();
                    this.ui.initializeMarkdownUploader();
                    this.ui.initializeFunctionBindingListener();
                    this.dom.apiExplorer.content.addEventListener('click', (e) => this.handlers.handleApiExplorerInteraction(e));
                    document.body.addEventListener('click', (e) => this.handlers.handleTokenToggle(e));
                    document.body.addEventListener('click', (e) => this.handlers.handleCopyContent(e));

                    // LLM Management event listeners
                    const llmPath = document.getElementById('path-llms');
                    if (llmPath) {
                        llmPath.addEventListener('click', (e) => {
                            if (e.target.id === 'llm-add-btn') {
                                this.handlers.handleAddModel(e.target);
                            } else if (e.target.classList.contains('btn-remove-model')) {
                                this.handlers.handleRemoveModel(e.target);
                            }
                        });

                        const providerSelect = document.getElementById('llm-provider-select');
                        if (providerSelect) {
                            providerSelect.addEventListener('change', (e) => {
                                this.ui.renderLlmProviderView(e.target.value);
                            });
                        }
                    }
                },

                updateState(key, value, sourceElement = null, preserveOpenApiUrls = false) {
                    const valueChanged = this.state[key] !== value;

                    if (key === 'endpointUrl' && valueChanged) {
                        sessionStorage.setItem('opal.endpointUrl', value);

                        if (!preserveOpenApiUrls) {
                            this.state.openApiUrls = this.generateDefaultOpenApiUrls();
                            this.ui.renderOpenApiUrlInputs();
                        }

                        this.handlers.resetAuthenticationState(true);
                        this.ui.updateBearerTokenLink();
                    }

                    this.state[key] = value;

                    document.querySelectorAll('.global-state-input').forEach(input => {
                        if (input.dataset.stateKey === key && input !== sourceElement) {
                            input.value = value;
                        }
                    });

                    if (valueChanged && ['chatId', 'model', 'question', 'title', 'top_p', 'temperature',
                        'modelApiKeyOverride', 'sessionFunctions', 'isAgentSession',
                        'currentAgent', 'lastChatCompletionBody'].includes(key)) {
                        this.ui.syncApiCards();
                    }
                },

                getDefaultOpenApiSpec() {
                    return {
                        "openapi": "3.0.0",
                        "info": { "title": "OpenLink Chat Service", "version": "1.0.0" },
                        "servers": [{ "url": "https://linkeddata.uriburner.com/chat/api" }],
                        "paths": {
                            "/listFunctions": { "get": { "operationId": "listFunctions", "tags": ["Function Tools"], "summary": "List available function tools.", "description": "Retrieve the list of available function tools.", "responses": { "200": { "description": "OK" } } } },
                            "/listFineTune": { "get": { "operationId": "listFineTune", "tags": ["Chat Session Management"], "summary": "List available AI Agents.", "description": "Retrieve the list of available pre-configured AI Agents/Assistants.", "responses": { "200": { "description": "OK" } } } },
                            "/createTopic": { "post": { "operationId": "createTopic", "tags": ["Chat Session Management"], "summary": "Create a new chat session.", "description": "Create a new empty chat session.", "security": [{ "VAL": [] }], "responses": { "200": { "description": "OK" } } } },
                            "/getModels": { "get": { "operationId": "getModels", "tags": ["Model Management"], "summary": "List available LLMs.", "description": "List bound LLMs", "responses": { "200": { "description": "OK" } } } },
                            "/chatTopic": { "post": { "operationId": "chatTopic-post", "tags": ["Chat Session Management"], "summary": "Update a chat session.", "description": "Update an existing chat session.", "parameters": [{ "name": "chat_id", "in": "query", "required": true, "schema": { "type": "string" } }], "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/chatTopicrequestBody" } } } }, "security": [{ "VAL": [] }], "responses": { "200": { "description": "OK" } } } },
                            "/chatCompletion": { "post": { "operationId": "chatCompletion", "tags": ["Chat Interaction"], "summary": "Send a prompt to a session.", "description": "Send a prompt to a chat session, optionally with function tools.", "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/chatCompletionrequestBody" } } } }, "security": [{ "VAL": [] }], "responses": { "200": { "description": "OK" } } } }
                        },
                        "components": {
                            "schemas": {
                                "chatCompletionrequestBody": { "type": "object", "properties": { "question": { "type": "string" }, "chat_id": { "type": "string" }, "model": { "type": "string" }, "apiKey": { "type": "string" }, "call": { "type": "array", "items": { "type": "string" } }, "alt_question": { "type": "string" } } },
                                "chatTopicrequestBody": { "type": "object", "properties": { "title": { "type": "string" }, "model": { "type": "string" }, "apiKey": { "type": "string" }, "top_p": { "type": "number", "format": "float" }, "temperature": { "type": "number", "format": "float" }, "call": { "type": "array", "items": { "type": "string" } } } },
                            }
                        }
                    };
                },

                generateDefaultOpenApiUrls() {
                    try {
                        const baseUrl = this.state.endpointUrl.replace(/\/+$/, '');
                        return [
                            `${baseUrl}/openapi.yaml`,
                            `${baseUrl.replace('/api', '')}/functions/openapi.yaml`
                        ];
                    } catch (e) {
                        return [
                            'https://linkeddata.uriburner.com/chat/api/openapi.yaml',
                            'https://linkeddata.uriburner.com/chat/functions/openapi.yaml'
                        ];
                    }
                },

                async makeApiCall({ url, method, body = null, isAuthenticated = false, responseElement, signal = null }) {
                    if (responseElement) {
                        this.ui.showLoading(responseElement);
                    }

                    const headers = { 'Content-Type': 'application/json' };
                    if (isAuthenticated) {
                        if (!this.state.apiKey) {
                            const error = new Error('API Key is required. Please provide it in Step 2.');
                            if (responseElement) this.ui.showError(responseElement, error);
                            return { data: null, error };
                        }
                        headers['Authorization'] = `Bearer ${this.state.apiKey}`;
                    }

                    try {
                        const response = await fetch(url, {
                            method,
                            headers,
                            body: body ? JSON.stringify(body) : null,
                            signal
                        });

                        if (response.status === 204 || response.status === 201) {
                            const successData = { status: response.status, statusText: response.statusText, data: null };
                            if (responseElement) this.ui.showSuccess(responseElement, successData);
                            return { data: successData, error: null };
                        }

                        const responseText = await response.text();

                        let responseData;
                        try {
                            responseData = JSON.parse(responseText);
                        } catch (e) {
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status} ${response.statusText}: ${responseText}`);
                            }
                            responseData = responseText;
                        }

                        if (responseData && responseData.error) {
                            throw new Error(responseData.error);
                        }

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status} ${response.statusText}: ${responseText}`);
                        }

                        const resultData = { status: response.status, statusText: response.statusText, data: responseData };
                        if (responseElement) this.ui.showSuccess(responseElement, resultData);
                        return { data: resultData, error: null };

                    } catch (error) {
                        if (error.name === 'AbortError') {
                            const message = `Operation was cancelled or timed out after ${App.state.apiTimeoutSeconds} seconds.`;
                            if (responseElement) this.ui.showError(responseElement, new Error(message));
                            console.warn(message);
                            return { data: null, error: new Error(message) };
                        }
                        if (responseElement) this.ui.showError(responseElement, error);
                        return { data: null, error };
                    }
                },

                handlers: {
                    handleOpenApiUrlInteraction(event) {
                        const target = event.target;
                        if (event.type === 'add') {
                            App.state.openApiUrls.push('');
                        } else if (target?.matches('.btn-remove-url')) {
                            const index = parseInt(target.dataset.index, 10);
                            if (!isNaN(index)) {
                                App.state.openApiUrls.splice(index, 1);
                            }
                        } else if (target?.matches('.openapi-spec-url')) {
                            const index = parseInt(target.dataset.index, 10);
                            if (!isNaN(index)) {
                                App.state.openApiUrls[index] = target.value;
                            }
                            return;
                        }
                        App.ui.renderOpenApiUrlInputs();
                    },

                    async handleLoadOpenApiSpec() {
                        const statusMsg = document.getElementById('spec-status-msg');
                        const endpointLabel = document.getElementById('qs-endpoint-url-label');
                        const originalLabelText = "Service Endpoint URL";
                        const urls = App.state.openApiUrls.map(url => url.trim()).filter(Boolean);

                        if (urls.length === 0) {
                            statusMsg.textContent = 'Please enter at least one URL.';
                            statusMsg.style.color = 'var(--color-error)';
                            return;
                        }

                        statusMsg.textContent = `Loading ${urls.length} spec(s)...`;
                        statusMsg.style.color = 'var(--color-text-muted)';

                        try {
                            const promises = urls.map(async (url) => {
                                const response = await fetch(url);
                                if (!response.ok) throw new Error(`HTTP error for ${url}! Status: ${response.status}`);
                                const text = await response.text();
                                return (url.endsWith('.yaml') || url.endsWith('.yml')) ? jsyaml.load(text) : JSON.parse(text);
                            });

                            const specs = await Promise.all(promises);
                            const mergedSpec = App.utils.mergeOpenApiSpecs(specs);
                            if (!mergedSpec) throw new Error('No valid specifications found.');

                            App.state.openApiSpec = mergedSpec;

                            const serverUrl = mergedSpec?.servers?.[0]?.url;
                            if (serverUrl) {
                                const absoluteUrl = new URL(serverUrl, urls[0]).href;
                                App.updateState('endpointUrl', absoluteUrl, null, true);

                                const serviceTitle = mergedSpec?.info?.title;
                                endpointLabel.innerHTML = serviceTitle ?
                                    `${originalLabelText} <span style="color: var(--color-success);">(from <em>${serviceTitle}</em>)</span>` :
                                    originalLabelText;
                            }

                            statusMsg.textContent = ` Spec(s) loaded! Endpoint updated.`;
                            statusMsg.style.color = 'var(--color-success)';
                            App.ui.scrollToStep('qs-step-2-authenticate');

                        } catch (error) {
                            console.error('Failed to load OpenAPI spec(s):', error);
                            statusMsg.textContent = ` Error: ${error.message}`;
                            statusMsg.style.color = 'var(--color-error)';
                            endpointLabel.textContent = originalLabelText;
                        }
                    },

                    async handleAuthAndCreate(button) {
                        const { data } = await App.makeApiCall({
                            url: `${App.state.endpointUrl}/createTopic`,
                            method: 'POST',
                            isAuthenticated: true,
                            responseElement: App.dom.qs.authResponseEl
                        });

                        if (data?.data?.chat_id) {
                            const newChatId = data.data.chat_id;
                            App.updateState('chatId', newChatId);
                            App.updateState('isAgentSession', false);
                            App.updateState('currentAgent', null);
                            App.state.currentSessionTools = [];
                            App.dom.qs.chatIdValue.textContent = newChatId;
                            App.dom.qs.chatIdDisplay.style.display = 'block';
                            App.ui.scrollToStep('qs-step-3-list-resources');
                        } else {
                            App.dom.qs.chatIdDisplay.style.display = 'none';
                        }
                    },

                    async handleListResources(button) {
                        const responseEl = App.dom.qs.listResponseEl;
                        button.disabled = true;
                        button.textContent = 'Loading...';
                        responseEl.textContent = 'Loading functions and agents...';

                        try {
                            const [functionsResponse, agentsResponse] = await Promise.all([
                                fetch(`${App.state.endpointUrl}/listFunctions`),
                                fetch(`${App.state.endpointUrl}/listFineTune`)
                            ]);

                            if (!functionsResponse.ok) throw new Error(`Functions fetch failed: ${functionsResponse.statusText}`);
                            if (!agentsResponse.ok) throw new Error(`Agents fetch failed: ${agentsResponse.statusText}`);

                            const functionsJson = await functionsResponse.json();
                            const agentsJson = await agentsResponse.json();

                            const functions = Array.isArray(functionsJson) ? functionsJson : functionsJson.functions || [];
                            App.state.availableFunctions = functions;

                            const agents = Array.isArray(agentsJson) ? agentsJson : agentsJson.agents || [];
                            App.state.availableAgents = agents;

                            App.ui.populateFunctionCheckboxes(functions, 'qs-function-selector-container');
                            App.ui.populateFunctionCheckboxes(functions, 'qs-agent-function-selector-container');
                            App.ui.populateModelDropdown('qs-update-model');
                            App.ui.populateModelDropdown('qs-agent-model');
                            App.ui.populateModelDropdown('qs-agent-model-select');
                            App.ui.populateAgentDropdown(agents);

                            responseEl.textContent = `Successfully loaded ${functions.length} function(s) and ${agents.length} agent(s).`;
                            responseEl.className = 'response-viewer success';
                            App.ui.scrollToStep('qs-step-4-interact');
                        } catch (error) {
                            responseEl.textContent = `Error: ${error.message}`;
                            responseEl.className = 'response-viewer error';
                        } finally {
                            button.disabled = false;
                            button.textContent = 'List Functions & Agents';
                        }
                    },

                    async handleListModels() {
                        const providerSelect = document.getElementById('llm-provider-select');
                        const llmProviderView = document.getElementById('llm-provider-view');

                        providerSelect.innerHTML = '<option value="">Loading providers...</option>';
                        llmProviderView.innerHTML = '<p style="color: var(--color-text-muted); font-style: italic; text-align: center; padding: 2rem;">Loading models...</p>';

                        try {
                            const { data, error } = await App.makeApiCall({
                                url: `${App.state.endpointUrl}/getModels`,
                                method: 'GET',
                                isAuthenticated: true,
                                responseElement: null
                            });

                            if (error) throw error;

                            const models = Array.isArray(data.data) ? data.data : [];

                            if (models.length === 0) {
                                providerSelect.innerHTML = '<option value="">No models found</option>';
                                llmProviderView.innerHTML = '<div class="llm-empty-state">No LLMs are currently configured. Add one below to get started.</div>';
                                return;
                            }

                            // Group models by provider
                            App.state.llmProviders = {};
                            const providers = new Set();

                            models.forEach(model => {
                                const provider = model.provider || 'unknown';
                                providers.add(provider);

                                if (!App.state.llmProviders[provider]) {
                                    App.state.llmProviders[provider] = [];
                                }
                                App.state.llmProviders[provider].push(model);
                            });

                            // Populate provider dropdown
                            App.ui.populateLlmProviderDropdown(Array.from(providers));

                            // Render the first provider's view
                            const firstProvider = Array.from(providers)[0];
                            if (firstProvider) {
                                providerSelect.value = firstProvider;
                                App.ui.renderLlmProviderView(firstProvider);
                            }

                        } catch (error) {
                            console.error('Failed to load models:', error);
                            providerSelect.innerHTML = '<option value="">Error loading providers</option>';
                            llmProviderView.innerHTML = `<div class="llm-empty-state" style="color: var(--color-error);">Error loading models: ${error.message}</div>`;
                        }
                    },

                    async handleAddModel(button) {
                        const modelIdInput = document.getElementById('llm-model-id-input');
                        const providerSelect = document.getElementById('llm-provider-select-add');
                        const customProviderInput = document.getElementById('llm-custom-provider-input');

                        if (!modelIdInput || !providerSelect) {
                            console.error('Model form inputs not found');
                            return;
                        }

                        const modelId = modelIdInput.value.trim();
                        let provider = providerSelect.value;

                        if (provider === '__custom__') {
                            provider = customProviderInput?.value.trim();
                            if (!provider) {
                                alert('Please enter a custom provider name.');
                                return;
                            }
                        }

                        if (!modelId || !provider) {
                            alert('Both Model ID and Provider are required.');
                            return;
                        }

                        const originalButtonText = button.textContent;
                        button.disabled = true;
                        button.textContent = 'Adding...';

                        try {
                            const formData = new URLSearchParams();
                            formData.append('modelId', modelId);
                            formData.append('provider', provider);

                            const response = await fetch(`${App.state.endpointUrl}/chatModels`, {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${App.state.apiKey}`,
                                    'Content-Type': 'application/x-www-form-urlencoded'
                                },
                                body: formData.toString()
                            });

                            if (!response.ok) {
                                const errorText = await response.text();
                                throw new Error(`HTTP ${response.status}: ${errorText}`);
                            }

                            modelIdInput.value = '';
                            if (customProviderInput) customProviderInput.value = '';
                            providerSelect.value = providerSelect.querySelector('option:not([value="__custom__"])')?.value || '';
                            document.getElementById('custom-provider-input').style.display = 'none';

                            await this.handleListModels();

                            const llmProviderView = document.getElementById('llm-provider-view');
                            const successMsg = document.createElement('div');
                            successMsg.style.cssText = 'background: var(--color-success); color: white; padding: 0.75rem; border-radius: 4px; margin-bottom: 1rem;';
                            successMsg.textContent = ` Model "${modelId}" added successfully to ${provider}!`;
                            llmProviderView.insertBefore(successMsg, llmProviderView.firstChild);
                            setTimeout(() => successMsg.remove(), 3000);

                        } catch (error) {
                            alert(`Failed to add model: ${error.message}`);
                        } finally {
                            button.disabled = false;
                            button.textContent = originalButtonText;
                        }
                    },

                    async handleRemoveModel(button) {
                        const modelId = button.dataset.modelId;
                        if (!modelId) return;
                        if (!confirm(`Are you sure you want to remove the model "${modelId}"?`)) return;

                        const originalButtonText = button.textContent;
                        button.disabled = true;
                        button.textContent = 'Removing...';

                        try {
                            const response = await fetch(`${App.state.endpointUrl}/chatModels?modelId=${encodeURIComponent(modelId)}`, {
                                method: 'DELETE',
                                headers: { 'Authorization': `Bearer ${App.state.apiKey}` }
                            });
                            if (!response.ok) throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                            await this.handleListModels();
                        } catch (error) {
                            alert(`Failed to remove model: ${error.message}`);
                            button.disabled = false;
                            button.textContent = originalButtonText;
                        }
                    },

                    async handleBindFunctions(button) {
                        if (!App.state.chatId) {
                            App.ui.showError(App.dom.qs.configResponseEl, new Error('Please create a session in Step 2 to get a Session ID.'));
                            return;
                        }
                        const body = {
                            title: App.state.title,
                            model: App.state.model,
                            call: App.state.sessionFunctions.map(f => f.function)
                        };
                        const { data } = await App.makeApiCall({
                            url: `${App.state.endpointUrl}/chatTopic?chat_id=${App.state.chatId}`,
                            method: 'POST',
                            isAuthenticated: true,
                            body,
                            responseElement: App.dom.qs.configResponseEl
                        });
                        if (data) {
                            App.ui.scrollToStep('qs-step-5-modify-session');
                        }
                    },

                    async handleInstantiateAgent(button) {
                        if (App.state.currentAbortController) {
                            App.state.currentAbortController.abort();
                            return;
                        }

                        const agentSelect = document.getElementById('qs-agent-select');
                        const agentConfigId = agentSelect.value;
                        const responseEl = App.dom.qs.configResponseEl;
                        const newTitle = document.getElementById('qs-agent-title-input').value.trim();

                        if (!agentConfigId) {
                            App.ui.showError(responseEl, new Error('Please select an agent.'));
                            return;
                        }

                        const originalState = { text: button.textContent, color: button.style.backgroundColor };
                        const controller = new AbortController();
                        App.state.currentAbortController = controller;
                        let animationIntervalId = null;

                        try {
                            animationIntervalId = App.ui.startCancellableOperation(button, 'Instantiating');
                            App.ui.showLoading(responseEl);

                            const timeoutId = setTimeout(() => controller.abort(), App.state.apiTimeoutSeconds * 1000);
                            App.state.currentAbortTimeout = timeoutId;

                            const selectedOption = agentSelect.selectedOptions[0];
                            const agentTitle = selectedOption.textContent;
                            const instantiationBody = { model: App.state.model, chat_id: agentConfigId };

                            const { data: instantiationResponse, error: instantiationError } = await App.makeApiCall({
                                url: `${App.state.endpointUrl}/chatCompletion`,
                                method: 'POST',
                                isAuthenticated: true,
                                body: instantiationBody,
                                responseElement: null,
                                signal: controller.signal
                            });
                            if (instantiationError) throw instantiationError;

                            const newChatId = instantiationResponse?.data?.chat_id;
                            if (!newChatId) throw new Error('Failed to get a new session ID from the server.');

                            if (newTitle) {
                                const { error: titleError } = await App.makeApiCall({
                                    url: `${App.state.endpointUrl}/chatTopic?chat_id=${newChatId}`,
                                    method: 'POST',
                                    isAuthenticated: true,
                                    body: { title: newTitle },
                                    responseElement: null,
                                    signal: controller.signal
                                });
                                if (titleError) {
                                    console.warn(`Could not set custom title: ${titleError.message}`);
                                    if (titleError.name === 'AbortError') throw titleError;
                                }
                            }

                            const { data: topicResponse, error: topicError } = await App.makeApiCall({
                                url: `${App.state.endpointUrl}/getTopic?chat_id=${newChatId}`,
                                method: 'GET',
                                isAuthenticated: true,
                                responseElement: null,
                                signal: controller.signal
                            });
                            if (topicError) throw new Error(`Failed to sync session state: ${topicError.message}`);

                            const sessionState = topicResponse?.data;
                            App.updateState('chatId', newChatId);
                            App.updateState('isAgentSession', true);
                            App.updateState('currentAgent', { title: agentTitle, chatId: newChatId, configId: agentConfigId });
                            App.state.currentSessionTools = sessionState?.funcs || [];
                            if (sessionState?.title) App.updateState('title', sessionState.title);

                            App.dom.qs.chatIdValue.textContent = newChatId;
                            App.dom.qs.chatIdDisplay.style.display = 'block';
                            App.ui.switchToAgentChatView(agentTitle, instantiationResponse.data.answer);
                            App.ui.showSuccess(responseEl, { data: instantiationResponse.data });

                        } catch (err) {
                            if (err.name !== 'AbortError') App.ui.showError(responseEl, err);
                        } finally {
                            clearTimeout(App.state.currentAbortTimeout);
                            App.ui.endCancellableOperation(button, animationIntervalId, originalState);
                            App.state.currentAbortController = null;
                            App.state.currentAbortTimeout = null;
                        }
                    },

                    async handleAgentChatCompletion(button) {
                        if (App.state.currentAbortController) {
                            App.state.currentAbortController.abort();
                            return;
                        }

                        const inputEl = App.dom.qs.agentChatInput;
                        const question = inputEl.value.trim();
                        if (!question) return;

                        App.updateState('question', question);
                        App.ui.appendMessageToChatLog(question, 'user');
                        inputEl.value = '';
                        inputEl.focus();

                        const originalState = { text: button.textContent, color: button.style.backgroundColor };
                        const controller = new AbortController();
                        App.state.currentAbortController = controller;
                        let animationIntervalId = null;

                        try {
                            animationIntervalId = App.ui.startCancellableOperation(button, 'Sending');

                            const timeoutId = setTimeout(() => controller.abort(), App.state.apiTimeoutSeconds * 1000);
                            App.state.currentAbortTimeout = timeoutId;

                            const body = {
                                question: question,
                                chat_id: App.state.chatId,
                                model: App.state.model,
                                call: App.state.currentSessionTools
                            };
                            const modelKeyOverride = document.getElementById('qs-agent-model-key').value;
                            if (modelKeyOverride.trim()) body.apiKey = modelKeyOverride;
                            App.updateState('lastChatCompletionBody', body);

                            const { data, error } = await App.makeApiCall({
                                url: `${App.state.endpointUrl}/chatCompletion`,
                                method: 'POST',
                                isAuthenticated: true,
                                body,
                                signal: controller.signal
                            });

                            if (error) {
                                if (error.name !== 'AbortError') App.ui.appendMessageToChatLog(`Error: ${error.message}`, 'system-error');
                                return;
                            }

                            const answer = (typeof data.data === 'object' && data.data.data) ? data.data.data : data.data.answer || JSON.stringify(data.data);
                            if (answer) {
                                App.ui.appendMessageToChatLog(answer, 'agent');
                            } else {
                                App.ui.appendMessageToChatLog(`Received an unexpected response: ${JSON.stringify(data?.data || 'empty response')}`, 'system-error');
                            }
                        } finally {
                            clearTimeout(App.state.currentAbortTimeout);
                            App.ui.endCancellableOperation(button, animationIntervalId, originalState);
                            App.state.currentAbortController = null;
                            App.state.currentAbortTimeout = null;
                        }
                    },

                    async handleSaveAgent(button) {
                        const davUrl = document.getElementById('qs-agent-dav-url').value;
                        let agentPrompt = document.getElementById('qs-agent-prompt').value;
                        const responseEl = App.dom.qs.configResponseEl;

                        const metadata = {
                            name: document.getElementById('qs-agent-id').value.trim(),
                            id: document.getElementById('qs-agent-id').value.trim(),
                            title: document.getElementById('qs-agent-title').value.trim(),
                            version: document.getElementById('qs-agent-version').value.trim(),
                            creationDate: document.getElementById('qs-agent-creation-date').value.trim(),
                            functions: App.state.sessionFunctions
                        };

                        if (!davUrl || !agentPrompt || !metadata.id || !metadata.title || !metadata.version) {
                            App.ui.showError(responseEl, new Error('WebDAV URL, Agent ID, Title, Version, and System Prompt are all required.'));
                            return;
                        }

                        try {
                            agentPrompt = agentPrompt.replace(/\*\*Name:\*\*\s*.+$/m, `**Name:** ${metadata.name}`);
                            agentPrompt = agentPrompt.replace(/\*\*Title:\*\*\s*.+$/m, `**Title:** ${metadata.title}`);
                            agentPrompt = agentPrompt.replace(/\*\*Version:\*\*\s*.+$/m, `**Version:** ${metadata.version}`);
                            agentPrompt = agentPrompt.replace(/\*\*Creation Date:\*\*\s*.+$/m, `**Creation Date:** ${metadata.creationDate}`);

                            const agentJson = App.utils.transformMarkdownToAgentJson(agentPrompt, metadata);
                            const finalUrl = `${davUrl.replace(/\/$/, '')}/${metadata.id}.json`;

                            const { data: result } = await App.makeApiCall({
                                url: finalUrl,
                                method: 'PUT',
                                isAuthenticated: true,
                                body: agentJson,
                                responseElement: responseEl
                            });

                            App.ui.displayAgentCreationResult(responseEl, result, agentJson, metadata);
                            if (result) {
                                await App.ui.populateAgentDropdown();
                                document.getElementById('choice-instantiate').checked = true;
                                document.getElementById('choice-instantiate').dispatchEvent(new Event('change', { bubbles: true }));
                                App.ui.scrollToStep('qs-step-4-interact');
                            }
                        } catch (error) {
                            console.error("Halting agent creation due to parsing error:", error);
                            App.ui.showError(responseEl, new Error(`Parsing Error: ${error.message}`));
                        }
                    },

                    async handleUpdateTopic(button) {
                        if (!App.state.chatId) {
                            App.ui.showError(App.dom.qs.updateTopicResponseEl, new Error('Please create a session first to get a Session ID.'));
                            return;
                        }
                        const body = {
                            title: document.getElementById('qs-update-title').value || App.state.title,
                            model: document.getElementById('qs-update-model').value || App.state.model,
                            top_p: parseFloat(document.getElementById('qs-update-top-p').value) || App.state.top_p,
                            temperature: parseFloat(document.getElementById('qs-update-temperature').value) || App.state.temperature
                        };
                        const modelKeyOverride = document.getElementById('qs-update-model-key').value;
                        if (modelKeyOverride.trim()) body.apiKey = modelKeyOverride;

                        const { data } = await App.makeApiCall({
                            url: `${App.state.endpointUrl}/chatTopic?chat_id=${App.state.chatId}`,
                            method: 'POST',
                            isAuthenticated: true,
                            body,
                            responseElement: App.dom.qs.updateTopicResponseEl
                        });
                        if (data) {
                            App.ui.scrollToStep('qs-step-6-ask-question');
                        }
                    },

                    async handleChatCompletion(button) {
                        if (App.state.currentAbortController) {
                            App.state.currentAbortController.abort();
                            return;
                        }
                        if (!App.state.chatId) {
                            App.ui.showError(App.dom.qs.chatCompletionResponseEl, new Error('Please create a session first to get a Session ID.'));
                            return;
                        }

                        const originalState = { text: button.textContent, color: button.style.backgroundColor };
                        const controller = new AbortController();
                        App.state.currentAbortController = controller;
                        let animationIntervalId = null;

                        try {
                            animationIntervalId = App.ui.startCancellableOperation(button, 'Sending');

                            const timeoutId = setTimeout(() => controller.abort(), App.state.apiTimeoutSeconds * 1000);
                            App.state.currentAbortTimeout = timeoutId;

                            const body = {
                                question: document.getElementById('qs-question').value || App.state.question,
                                chat_id: App.state.chatId,
                                model: document.getElementById('qs-update-model').value || App.state.model
                            };
                            const manualFunctions = App.state.sessionFunctions;
                            if (!App.state.isAgentSession && manualFunctions.length > 0) {
                                body.call = manualFunctions.map(f => f.function);
                            }
                            const modelKeyOverride = document.getElementById('qs-update-model-key').value;
                            if (modelKeyOverride.trim()) body.apiKey = modelKeyOverride;

                            await App.makeApiCall({
                                url: `${App.state.endpointUrl}/chatCompletion`,
                                method: 'POST',
                                isAuthenticated: true,
                                body,
                                responseElement: App.dom.qs.chatCompletionResponseEl,
                                signal: controller.signal
                            });
                        } catch (err) {
                            if (err.name !== 'AbortError') App.ui.showError(App.dom.qs.chatCompletionResponseEl, err);
                        } finally {
                            clearTimeout(App.state.currentAbortTimeout);
                            App.ui.endCancellableOperation(button, animationIntervalId, originalState);
                            App.state.currentAbortController = null;
                            App.state.currentAbortTimeout = null;
                        }
                    },

                    async handleOAuthLogin(button) {
                        const statusEl = App.dom.qs.oauthStatusMsg;
                        const clientIdGroup = App.dom.qs.oauthClientIdGroup;
                        let clientId = '';
                        const originalButtonText = button.textContent;

                        try {
                            button.disabled = true;
                            button.textContent = 'Discovering...';
                            statusEl.textContent = "Discovering OAuth endpoints...";
                            statusEl.style.color = 'var(--color-text-muted)';
                            clientIdGroup.style.display = 'none';

                            const origin = new URL(App.state.endpointUrl).origin;
                            const endpoints = await App.utils.discoverOAuthEndpoints(origin, statusEl);
                            App.state.oauthEndpoints = endpoints;

                            if (endpoints.registration_endpoint) {
                                button.textContent = 'Registering...';
                                statusEl.textContent = "Dynamically registering client...";
                                const regResponse = await fetch(endpoints.registration_endpoint, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        client_name: "OPAL Playground",
                                        redirect_uris: [window.location.origin + window.location.pathname],
                                        grant_types: ["authorization_code"],
                                        token_endpoint_auth_method: "none"
                                    })
                                });
                                if (!regResponse.ok) throw new Error('Dynamic client registration failed.');
                                const regData = await regResponse.json();
                                clientId = regData.client_id;
                                App.updateState('oauthClientId', clientId);
                                statusEl.textContent = "Dynamic client registered successfully.";
                            } else {
                                statusEl.textContent = "Provider does not support dynamic registration. Please enter a Client ID.";
                                clientIdGroup.style.display = 'block';
                                clientId = App.state.oauthClientId;
                                if (!clientId) {
                                    throw new Error("Client ID is required as provider does not support dynamic registration.");
                                }
                            }

                            const { verifier, challenge } = await App.utils.generatePkceChallenge();

                            const nonce = App.utils.generateRandomString();
                            const stateObject = {
                                nonce: nonce,
                                origin: App.state.endpointUrl
                            };
                            const state = btoa(JSON.stringify(stateObject));
                            sessionStorage.setItem('oauth_state_nonce', nonce);

                            sessionStorage.setItem('oauth_pkce_verifier', verifier);
                            sessionStorage.setItem('oauth_client_id', clientId);

                            const params = new URLSearchParams({
                                response_type: 'code',
                                client_id: clientId,
                                redirect_uri: window.location.origin + window.location.pathname,
                                scope: 'openid profile email',
                                state: state,
                                code_challenge: challenge,
                                code_challenge_method: 'S256'
                            });

                            button.textContent = 'Redirecting...';
                            statusEl.textContent = "Redirecting to login...";
                            window.location.href = `${endpoints.authorization_endpoint}?${params.toString()}`;
                        } catch (error) {
                            statusEl.textContent = `Error: ${error.message}`;
                            statusEl.style.color = 'var(--color-error)';
                            button.disabled = false;
                            button.textContent = originalButtonText;
                        }
                    },

                    resetAuthenticationState(isAutomatic = false) {
                        App.updateState('apiKey', '');
                        App.updateState('chatId', '');
                        App.updateState('oauthClientId', '');
                        App.updateState('isAgentSession', false);
                        App.updateState('currentAgent', null);
                        App.state.oauthEndpoints = null;
                        App.state.currentSessionTools = [];
                        App.utils.clearOAuthSession();
                        App.ui.resetApiKeyState(isAutomatic);
                    },

                    async handleOAuthCallback() {
                        const params = new URLSearchParams(window.location.search);
                        const code = params.get('code');
                        const encodedState = params.get('state');

                        if (!code || !encodedState) return;

                        history.replaceState(null, '', window.location.pathname);
                        const statusEl = App.dom.qs.oauthStatusMsg;

                        let stateObject;
                        try {
                            stateObject = JSON.parse(atob(encodedState));
                        } catch (e) {
                            statusEl.textContent = "Error: Invalid state parameter format.";
                            statusEl.style.color = 'var(--color-error)';
                            App.utils.clearOAuthSession();
                            return;
                        }

                        const { nonce, origin } = stateObject;
                        const storedNonce = sessionStorage.getItem('oauth_state_nonce');

                        if (nonce !== storedNonce) {
                            statusEl.textContent = "Error: Invalid state nonce. Possible CSRF attack.";
                            statusEl.style.color = 'var(--color-error)';
                            App.utils.clearOAuthSession();
                            return;
                        }

                        if (!origin) {
                            statusEl.textContent = "Error: Origin URL not found in state parameter.";
                            statusEl.style.color = 'var(--color-error)';
                            App.utils.clearOAuthSession();
                            return;
                        }

                        const verifier = sessionStorage.getItem('oauth_pkce_verifier');
                        const clientId = sessionStorage.getItem('oauth_client_id');
                        if (!verifier || !clientId) {
                            statusEl.textContent = "Error: OAuth session data (verifier or client ID) not found.";
                            statusEl.style.color = 'var(--color-error)';
                            App.utils.clearOAuthSession();
                            return;
                        }

                        try {
                            statusEl.textContent = "Exchanging authorization code for token...";
                            statusEl.style.color = 'var(--color-text-muted)';

                            const currentOrigin = new URL(App.state.endpointUrl).origin;
                            const endpoints = await App.utils.discoverOAuthEndpoints(currentOrigin, statusEl);

                            const tokenResponse = await fetch(endpoints.token_endpoint, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                                body: new URLSearchParams({
                                    grant_type: 'authorization_code',
                                    code: code,
                                    redirect_uri: window.location.origin + window.location.pathname,
                                    client_id: clientId,
                                    code_verifier: verifier
                                })
                            });

                            if (!tokenResponse.ok) {
                                const errorData = await tokenResponse.json();
                                throw new Error(errorData.error_description || 'Token exchange failed.');
                            }

                            const tokenData = await tokenResponse.json();
                            App.updateState('apiKey', tokenData.access_token);

                            App.updateState('oauthClientId', clientId);
                            App.ui.setOAuthSuccessState();

                            App.dom.qs.authAndCreateBtn.click();

                        } catch (error) {
                            statusEl.textContent = `Error: ${error.message}`;
                            statusEl.style.color = 'var(--color-error)';
                        } finally {
                            App.utils.clearOAuthSession();
                        }
                    },

                    handleApiExplorerInteraction(event) {
                        const header = event.target.closest('.endpoint-header');
                        if (header) {
                            const card = header.parentElement;
                            card.classList.toggle('open');
                            if (card.classList.contains('open')) {
                                App.ui.updateCodeSnippetsForCard(card);
                            }
                            return;
                        }

                        const runBtn = event.target.closest('.btn-run');
                        if (runBtn) {
                            const card = runBtn.closest('.endpoint-card');
                            const { path, method, requiresAuth, params, body } = App.utils.getEndpointData(card.id);
                            const responseEl = card.querySelector('.response-viewer');

                            let fullUrl = `${App.state.endpointUrl}${path}`;
                            const queryParams = new URLSearchParams(params.query);
                            if (queryParams.toString()) {
                                fullUrl += `?${queryParams.toString()}`;
                            }

                            App.makeApiCall({
                                url: fullUrl,
                                method: method.toUpperCase(),
                                isAuthenticated: requiresAuth,
                                body,
                                responseElement: responseEl
                            });
                            App.ui.updateCodeSnippetsForCard(card);
                            return;
                        }

                        const tab = event.target.closest('.code-tab');
                        if (tab) {
                            const card = tab.closest('.endpoint-card');
                            const lang = tab.dataset.lang;
                            card.querySelectorAll('.code-tab').forEach(t => t.classList.remove('active'));
                            card.querySelectorAll('.code-snippet').forEach(s => s.classList.remove('active'));
                            tab.classList.add('active');
                            card.querySelector(`.code-snippet[data-lang="${lang}"]`).classList.add('active');
                        }
                    },

                    handleTokenToggle(event) {
                        if (event.target.matches('.btn-toggle-token')) {
                            const btn = event.target;
                            const wrapper = btn.closest('.response-viewer-wrapper');
                            if (!wrapper) return;
                            const responseViewer = wrapper.querySelector('.response-viewer');
                            if (!responseViewer) return;

                            if (btn.dataset.state === 'masked') {
                                responseViewer.textContent = responseViewer.dataset.unmasked;
                                btn.textContent = 'Hide Token';
                                btn.dataset.state = 'unmasked';
                            } else {
                                responseViewer.textContent = responseViewer.dataset.masked;
                                btn.textContent = 'Show Token';
                                btn.dataset.state = 'masked';
                            }
                        }
                    },

                    handleCopyContent(event) {
                        const btn = event.target.closest('.btn-copy-content');
                        if (!btn) return;

                        let content = '';
                        const targetId = btn.dataset.targetId;

                        if (targetId) {
                            const targetElement = document.getElementById(targetId);
                            if (targetElement) {
                                content = targetElement.tagName === 'TEXTAREA' ? targetElement.value : targetElement.textContent;
                            }
                        } else {
                            const messageContent = btn.closest('.message')?.querySelector('.message-content');
                            if (messageContent) {
                                content = messageContent.textContent;
                            }
                        }

                        if (content) {
                            navigator.clipboard.writeText(content).then(() => {
                                const originalText = btn.textContent;
                                btn.textContent = 'Copied!';
                                btn.style.backgroundColor = 'var(--color-success)';
                                setTimeout(() => {
                                    btn.textContent = originalText;
                                    btn.style.backgroundColor = '';
                                }, 2000);
                            }).catch(err => {
                                console.error('Failed to copy content: ', err);
                                const originalText = btn.textContent;
                                btn.textContent = 'Error!';
                                btn.style.backgroundColor = 'var(--color-error)';
                                setTimeout(() => {
                                    btn.textContent = originalText;
                                    btn.style.backgroundColor = '';
                                }, 2000);
                            });
                        }
                    }
                },

                ui: {
                    startCancellableOperation(button, baseText) {
                        button.disabled = false;
                        button.style.backgroundColor = 'var(--color-error)';
                        let dotCount = 1;
                        const intervalId = setInterval(() => {
                            const dots = '.'.repeat(dotCount);
                            button.textContent = `${baseText}${dots} (Click to Cancel)`;
                            dotCount = (dotCount % 3) + 1;
                        }, 500);
                        return intervalId;
                    },

                    endCancellableOperation(button, intervalId, originalState) {
                        clearInterval(intervalId);
                        button.disabled = false;
                        button.textContent = originalState.text;
                        button.style.backgroundColor = originalState.color;
                    },

                    showLoading(element) {
                        if (!element) return;
                        element.textContent = 'Loading...';
                        element.className = 'response-viewer';
                        element.style.display = 'block';
                    },

                    showError(element, error) {
                        if (!element) return;
                        element.textContent = `Error: ${error.message}`;
                        element.className = 'response-viewer error';
                        element.style.display = 'block';
                    },

                    showSuccess(element, result) {
                        if (!element) return;
                        element.className = 'response-viewer success';
                        element.style.display = 'block';

                        if (result.status === 204 || result.status === 201) {
                            element.textContent = `Success: ${result.status} ${result.statusText}`;
                            return;
                        }

                        const jsonString = typeof result.data === 'object' ? JSON.stringify(result.data, null, 2) : String(result.data);
                        element.textContent = jsonString;
                    },

                    populateLlmProviderDropdown(providers) {
                        const providerSelect = document.getElementById('llm-provider-select');
                        if (!providerSelect) return;

                        if (!providers || providers.length === 0) {
                            providerSelect.innerHTML = '<option value="">No providers found</option>';
                            return;
                        }

                        providerSelect.innerHTML = '';
                        providers.sort().forEach(provider => {
                            const option = document.createElement('option');
                            option.value = provider;
                            option.textContent = provider.charAt(0).toUpperCase() + provider.slice(1);
                            providerSelect.appendChild(option);
                        });
                    },

                    renderLlmProviderView(providerName) {
                        const llmProviderView = document.getElementById('llm-provider-view');
                        if (!llmProviderView || !providerName) return;

                        const models = App.state.llmProviders[providerName] || [];

                        const allProviders = Object.keys(App.state.llmProviders).sort();

                        let html = '';

                        html += '<div class="llm-list">';
                        html += '<h5>Currently Bound LLMs</h5>';

                        if (models.length === 0) {
                            html += '<div class="llm-empty-state">No models found for this provider.</div>';
                        } else {
                            models.forEach(model => {
                                const modelId = model.id || model.model || 'Unknown';
                                html += `
                <div class="llm-item">
                    <div class="llm-item-info">
                        <div class="llm-item-name">${modelId}</div>
                        <div class="llm-item-provider">Provider: ${providerName}</div>
                    </div>
                    <button class="btn-remove-model" data-model-id="${modelId}" data-provider="${providerName}">
                        Remove
                    </button>
                </div>
            `;
                            });
                        }
                        html += '</div>';

                        html += '<div class="llm-form">';
                        html += '<h5>Add New LLM</h5>';
                        html += '<div class="llm-form-row">';

                        html += '<div class="input-group">';
                        html += '<label for="llm-provider-select-add">Provider</label>';
                        html += '<select id="llm-provider-select-add">';
                        allProviders.forEach(provider => {
                            const selected = provider === providerName ? ' selected' : '';
                            html += `<option value="${provider}"${selected}>${provider.charAt(0).toUpperCase() + provider.slice(1)}</option>`;
                        });
                        html += '<option value="__custom__">+ Add Custom Provider</option>';
                        html += '</select>';
                        html += '</div>';

                        html += '<div class="input-group">';
                        html += '<label for="llm-model-id-input">Model ID</label>';
                        html += '<input type="text" id="llm-model-id-input" placeholder="e.g., gpt-4o-mini">';
                        html += '</div>';

                        html += '<button id="llm-add-btn" class="btn btn-primary">Add</button>';
                        html += '</div>';

                        html += '<div id="custom-provider-input" style="display: none; margin-top: 1rem;">';
                        html += '<div class="input-group">';
                        html += '<label for="llm-custom-provider-input">Custom Provider Name</label>';
                        html += '<input type="text" id="llm-custom-provider-input" placeholder="e.g., anthropic">';
                        html += '</div>';
                        html += '</div>';

                        html += '</div>';

                        llmProviderView.innerHTML = html;

                        const providerSelect = document.getElementById('llm-provider-select-add');
                        const customProviderInput = document.getElementById('custom-provider-input');
                        if (providerSelect && customProviderInput) {
                            providerSelect.addEventListener('change', (e) => {
                                customProviderInput.style.display = e.target.value === '__custom__' ? 'block' : 'none';
                            });
                        }
                    },

                    switchToAgentChatView(agentTitle, initialMessage) {
                        App.dom.qs.agentCreationBlock.style.display = 'none';
                        App.dom.qs.agentInteractionBlock.style.display = 'block';
                        App.dom.qs.activeAgentName.textContent = agentTitle;

                        const chatLog = App.dom.qs.configResponseEl;
                        chatLog.innerHTML = '';
                        chatLog.className = 'response-viewer chat-log';

                        if (initialMessage) {
                            this.appendMessageToChatLog(initialMessage, 'agent');
                        } else {
                            this.appendMessageToChatLog(`Hello! I am ${agentTitle}. How can I assist you?`, 'agent');
                        }

                        App.dom.qs.agentChatInput.focus();
                    },

                    switchToAgentSelectionView() {
                        App.dom.qs.agentCreationBlock.style.display = 'block';
                        App.dom.qs.agentInteractionBlock.style.display = 'none';
                        App.updateState('chatId', '');
                        App.updateState('isAgentSession', false);
                        App.updateState('currentAgent', null);
                        App.updateState('lastChatCompletionBody', null);

                        const responseEl = App.dom.qs.configResponseEl;
                        responseEl.innerHTML = 'Response will appear here...';
                        responseEl.className = 'response-viewer';
                    },

                    appendMessageToChatLog(message, sender) {
                        const chatLog = App.dom.qs.configResponseEl;
                        const messageDiv = document.createElement('div');
                        messageDiv.className = 'message';

                        const senderDiv = document.createElement('div');
                        senderDiv.className = `message-sender ${sender}`;
                        senderDiv.textContent = sender === 'user' ? 'You' : (App.state.currentAgent?.title || 'Agent');
                        if (sender === 'system-error') {
                            senderDiv.textContent = 'System Error';
                            senderDiv.style.color = 'var(--color-error)';
                        }

                        const contentDiv = document.createElement('div');
                        contentDiv.className = 'message-content';
                        contentDiv.innerHTML = sender === 'agent' ? marked.parse(message) : `<p>${message}</p>`;

                        messageDiv.appendChild(senderDiv);
                        messageDiv.appendChild(contentDiv);

                        if (sender === 'agent' || sender === 'system-error') {
                            const copyBtn = document.createElement('button');
                            copyBtn.className = 'btn-copy-content';
                            copyBtn.title = 'Copy this message';
                            copyBtn.textContent = 'Copy';
                            messageDiv.appendChild(copyBtn);
                        }

                        chatLog.appendChild(messageDiv);

                        chatLog.scrollTop = chatLog.scrollHeight;
                    },

                    updateAllStateInputs() {
                        document.querySelectorAll('.global-state-input').forEach(input => {
                            const key = input.dataset.stateKey;
                            if (App.state.hasOwnProperty(key)) {
                                input.value = App.state[key];
                            }
                        });
                    },

                    renderOpenApiUrlInputs() {
                        const container = App.dom.qs.openapiUrlsContainer;
                        container.innerHTML = '';
                        App.state.openApiUrls.forEach((url, index) => {
                            const row = document.createElement('div');
                            row.className = 'openapi-url-row';
                            row.style.cssText = 'display: flex; gap: 0.5rem; margin-bottom: 0.5rem;';
                            row.innerHTML = `
                                <input type="text" class="openapi-spec-url" value="${url}" data-index="${index}">
                                <button class="btn-remove-url" data-index="${index}" style="flex-shrink: 0; display: ${App.state.openApiUrls.length > 1 ? 'inline-block' : 'none'};">Remove</button>
                            `;
                            container.appendChild(row);
                        });
                    },

                    renderApiExplorer() {
                        const sidebar = App.dom.apiExplorer.sidebar;
                        const content = App.dom.apiExplorer.content;
                        sidebar.innerHTML = '';
                        content.innerHTML = '';

                        const endpointsByTag = {};
                        for (const [path, methods] of Object.entries(App.state.openApiSpec.paths)) {
                            for (const [method, details] of Object.entries(methods)) {
                                const tag = details.tags?.[0] || 'default';
                                if (!endpointsByTag[tag]) endpointsByTag[tag] = [];
                                endpointsByTag[tag].push({ path, method, ...details });
                            }
                        }

                        Object.keys(endpointsByTag).sort().forEach(tag => {
                            const categoryId = `category-${tag.replace(/\s+/g, '-').toLowerCase()}`;
                            sidebar.innerHTML += `<li><a href="#${categoryId}">${tag.replace(/_/g, ' ')}</a></li>`;
                            let categoryHtml = `<div id="${categoryId}" class="api-category"><h2>${tag.replace(/_/g, ' ')}</h2>`;

                            endpointsByTag[tag].forEach((endpoint, index) => {
                                const endpointId = `${categoryId}-endpoint-${index}`;
                                const summary = endpoint.summary || endpoint.description.split('\n')[0];

                                categoryHtml += `
                                <div class="endpoint-card" id="${endpointId}">
                                    <div class="endpoint-header">
                                        <span class="method-badge ${endpoint.method}">${endpoint.method.toUpperCase()}</span>
                                        <span class="endpoint-path">${endpoint.path}</span>
                                        <span class="endpoint-summary" title="${endpoint.description}">${summary}</span>
                                    </div>
                                    <div class="endpoint-body">
                                        <p>${endpoint.description}</p>
                                        <div class="endpoint-section params-section">
                                            ${(endpoint.parameters && endpoint.parameters.length > 0) || endpoint.requestBody ? '<h4>Parameters</h4>' : ''}
                                            <div class="param-table">
                                                ${(endpoint.parameters || []).map(p => `
                                                    <div class="input-group">
                                                        <label for="${endpointId}-${p.name}">
                                                            ${p.name} ${p.required ? '<span class="required-dot">*</span>' : ''}
                                                            <span class="param-type">${p.schema.type} (${p.in})</span>
                                                        </label>
                                                        <input type="text" id="${endpointId}-${p.name}" data-param-name="${p.name}" data-param-in="${p.in}"
                                                            value="${p.required ? App.utils.getSensibleDefault(p.schema, p.name) : ''}"
                                                            placeholder="${p.schema.type}">
                                                    </div>
                                                `).join('')}
                                            </div>
                                            ${endpoint.requestBody ? `
                                                <h4>Request Body</h4>
                                                <div class="input-group">
                                                    <textarea id="${endpointId}-body" class="request-body-input">${App.utils.generateBodyTemplate(endpoint.requestBody.content['application/json']?.schema?.$ref, endpoint.operationId)}</textarea>
                                                </div>
                                            ` : ''}
                                        </div>
                                        <div class="endpoint-section">
                                            <h4>Try It Live</h4>
                                            <div class="try-it-live">
                                                <button class="btn btn-run" data-endpoint-id="${endpointId}">Try It Live</button>
                                                <pre class="response-viewer">Response will appear here...</pre>
                                            </div>
                                        </div>
                                        <div class="endpoint-section">
                                            <h4>Code Examples</h4>
                                            <div class="code-tabs">
                                                <div class="code-tab active" data-lang="curl">cURL</div>
                                                <div class="code-tab" data-lang="javascript">JavaScript</div>
                                                <div class="code-tab" data-lang="typescript">TypeScript</div>
                                                <div class="code-tab" data-lang="python">Python</div>
                                                <div class="code-tab" data-lang="java">Java</div>
                                                <div class="code-tab" data-lang="rust">Rust</div>
                                            </div>
                                            <div class="code-snippet-container">
                                                <pre class="code-snippet active" data-lang="curl"></pre>
                                                <pre class="code-snippet" data-lang="javascript"></pre>
                                                <pre class="code-snippet" data-lang="typescript"></pre>
                                                <pre class="code-snippet" data-lang="python"></pre>
                                                <pre class="code-snippet" data-lang="java"></pre>
                                                <pre class="code-snippet" data-lang="rust"></pre>
                                            </div>
                                        </div>
                                    </div>
                                </div>`;
                            });
                            categoryHtml += `</div>`;
                            content.innerHTML += categoryHtml;
                        });
                        this.syncApiCards();
                    },

                    syncApiCards() {
                        const syncCard = (path, method, updateFn) => {
                            const card = Array.from(document.querySelectorAll('.endpoint-card')).find(c =>
                                c.querySelector('.endpoint-path')?.textContent === path &&
                                c.querySelector('.method-badge')?.textContent.toLowerCase() === method
                            );
                            if (card) updateFn(card);
                        };

                        syncCard('/chatCompletion', 'post', (card) => {
                            const textarea = card.querySelector('.request-body-input');
                            if (!textarea) return;
                            try {
                                if (App.state.lastChatCompletionBody) {
                                    textarea.value = JSON.stringify(App.state.lastChatCompletionBody, null, 2);
                                    return;
                                }
                                const bodyJson = JSON.parse(textarea.value);
                                bodyJson.chat_id = App.state.chatId || App.utils.getSensibleDefault({ type: 'string' }, 'chat_id');
                                bodyJson.model = App.state.model;
                                bodyJson.question = App.state.question;
                                if (App.state.isAgentSession) {
                                    if (App.state.lastChatCompletionBody?.call) {
                                        bodyJson.call = App.state.lastChatCompletionBody.call;
                                    } else if (App.state.currentSessionTools && App.state.currentSessionTools.length > 0) {
                                        bodyJson.call = App.state.currentSessionTools;
                                    } else {
                                        delete bodyJson.call;
                                    }
                                } else {
                                    if (App.state.sessionFunctions.length > 0) {
                                        bodyJson.call = App.state.sessionFunctions.map(f => f.function);
                                    } else {
                                        delete bodyJson.call;
                                    }
                                }

                                if (App.state.modelApiKeyOverride.trim()) {
                                    bodyJson.apiKey = App.state.isApiKeyVisible ? App.state.modelApiKeyOverride : '[...masked for security...]';
                                } else {
                                    delete bodyJson.apiKey;
                                }
                                textarea.value = JSON.stringify(bodyJson, null, 2);
                            } catch (e) { }
                        });

                        syncCard('/chatTopic', 'post', (card) => {
                            const chatIdInput = card.querySelector('input[data-param-name="chat_id"]');
                            if (chatIdInput) chatIdInput.value = App.state.chatId;

                            const textarea = card.querySelector('.request-body-input');
                            if (!textarea) return;
                            try {
                                const bodyJson = JSON.parse(textarea.value);
                                bodyJson.title = App.state.title;
                                bodyJson.model = App.state.model;
                                bodyJson.top_p = App.state.top_p;
                                bodyJson.temperature = App.state.temperature;
                                if (App.state.modelApiKeyOverride.trim()) {
                                    bodyJson.apiKey = App.state.isApiKeyVisible ? App.state.modelApiKeyOverride : '[...masked for security...]';
                                } else {
                                    delete bodyJson.apiKey;
                                }
                                textarea.value = JSON.stringify(bodyJson, null, 2);
                            } catch (e) { }
                        });
                    },

                    updateCodeSnippetsForCard(cardElement) {
                        const endpointId = cardElement.id;
                        if (!endpointId) return;
                        const endpointData = App.utils.getEndpointData(endpointId);
                        ['curl', 'javascript', 'typescript', 'python', 'java', 'rust'].forEach(lang => {
                            const snippet = App.utils.generateCodeSnippet(lang, endpointData);
                            const snippetElement = cardElement.querySelector(`.code-snippet[data-lang="${lang}"]`);
                            if (snippetElement) snippetElement.textContent = snippet;
                        });
                    },

                    async populateModelDropdown(selectId) {
                        const selectEl = document.getElementById(selectId);
                        if (!selectEl) return;
                        selectEl.innerHTML = '<option>Loading models...</option>';
                        try {
                            const response = await fetch(`${App.state.endpointUrl}/getModels`);
                            if (!response.ok) throw new Error(`HTTP ${response.status}`);
                            const models = await response.json();

                            if (Array.isArray(models) && models.length > 0) {
                                selectEl.innerHTML = '';
                                models.forEach(model => {
                                    const modelId = model.id || model.model;
                                    if (modelId) {
                                        const option = document.createElement('option');
                                        option.value = modelId;
                                        option.textContent = modelId;
                                        selectEl.appendChild(option);
                                    }
                                });
                                if (selectEl.querySelector(`option[value="${App.state.model}"]`)) {
                                    selectEl.value = App.state.model;
                                } else if (selectEl.querySelector('option[value="gpt-4o-mini"]')) {
                                    selectEl.value = 'gpt-4o-mini';
                                }
                                App.updateState('model', selectEl.value);
                            } else {
                                throw new Error('Model data is not a valid array.');
                            }
                        } catch (error) {
                            console.error(`Could not populate model dropdown for #${selectId}:`, error);
                            const parent = selectEl.parentElement;
                            if (selectEl.tagName === 'SELECT') {
                                const input = document.createElement('input');
                                input.type = 'text';
                                input.id = selectId;
                                input.value = App.state.model;
                                parent.replaceChild(input, selectEl);
                                const label = parent.querySelector('label');
                                if (label) label.innerHTML += ' (manual entry)';
                            }
                        }
                    },

                    async populateAgentDropdown(agents) {
                        const selectEl = document.getElementById('qs-agent-select');
                        selectEl.innerHTML = '<option>Loading agents...</option>';
                        try {
                            if (!agents) {
                                const response = await fetch(`${App.state.endpointUrl}/listFineTune`);
                                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                                agents = await response.json();
                            }
                            if (Array.isArray(agents) && agents.length > 0) {
                                selectEl.innerHTML = '';
                                agents.forEach(agent => {
                                    if (agent.chat_id && agent.title) {
                                        const option = document.createElement('option');
                                        option.value = agent.chat_id;
                                        option.textContent = agent.title;
                                        selectEl.appendChild(option);
                                    }
                                });
                            } else {
                                selectEl.innerHTML = '<option>No agents found.</option>';
                            }
                        } catch (error) {
                            console.error('Could not populate agent dropdown:', error);
                            selectEl.innerHTML = '<option>Error loading agents.</option>';
                        }
                    },

                    populateFunctionCheckboxes(functions, containerId) {
                        const container = document.getElementById(containerId);
                        if (!container) return;
                        if (!Array.isArray(functions) || functions.length === 0) {
                            container.innerHTML = '<p><i>No functions available to bind.</i></p>';
                            return;
                        }
                        container.innerHTML = `
                            <div class="function-selector">
                                <h5>Bind Functions to Session</h5>
                                <div class="function-list">
                                    ${functions.map(funcObj => `
                                        <div class="function-item">
                                            <input type="checkbox" id="${containerId}-func-${funcObj.name}" value="${funcObj.function}" data-title="${funcObj.title}">
                                            <label for="${containerId}-func-${funcObj.name}" title="${funcObj.function}">${funcObj.title}</label>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>`;
                    },

                    displayAgentCreationResult(responseEl, result, originalJson, metadata) {
                        responseEl.innerHTML = '';
                        responseEl.className = 'response-viewer';
                        responseEl.style.textAlign = 'left';

                        const isSuccess = result && (result.status === 201 || result.status === 204);

                        const originalView = document.createElement('div');
                        originalView.id = 'originalView';
                        const statusMessage = document.createElement('p');
                        statusMessage.style.marginBottom = '1rem';
                        if (isSuccess) {
                            statusMessage.innerHTML = ` <strong>Success: ${result.status} ${result.statusText}</strong>. Agent configuration saved.`;
                            responseEl.classList.add('success');
                        } else {
                            statusMessage.innerHTML = ` <strong>API call failed.</strong> You can manually save the following JSON to a file.`;
                            responseEl.classList.add('error');
                        }
                        originalView.appendChild(statusMessage);

                        const originalButtonContainer = document.createElement('div');
                        originalButtonContainer.style.marginBottom = '1rem';
                        const copyOriginalBtn = document.createElement('button');
                        copyOriginalBtn.textContent = 'Copy Internal JSON';
                        copyOriginalBtn.className = 'btn btn-secondary';
                        copyOriginalBtn.addEventListener('click', () => App.utils.copyToClipboard(JSON.stringify(originalJson, null, 2), copyOriginalBtn));
                        originalButtonContainer.appendChild(copyOriginalBtn);
                        originalView.appendChild(originalButtonContainer);

                        const originalDetails = document.createElement('details');
                        originalDetails.open = true;
                        originalDetails.innerHTML = `<summary>Generated JSON Payload (Internal Format)</summary><pre>${JSON.stringify(originalJson, null, 2)}</pre>`;
                        originalView.appendChild(originalDetails);
                        responseEl.appendChild(originalView);

                        if (isSuccess) {
                            const gptView = document.createElement('div');
                            gptView.id = 'gptView';
                            gptView.style.display = 'none';

                            try {
                                const agentPrompt = document.getElementById('qs-agent-prompt').value;
                                const openAIJson = App.utils.transformMarkdownToOpenAIJson(agentPrompt, metadata);
                                const gptJsonString = JSON.stringify(openAIJson, null, 2);

                                gptView.innerHTML = `<p style="margin-bottom: 1rem;"> <strong>OpenAI-compatible JSON Generated Successfully</strong></p>`;
                                const gptButtonContainer = document.createElement('div');
                                gptButtonContainer.style.marginBottom = '1rem';

                                const copyGptBtn = document.createElement('button');
                                copyGptBtn.textContent = 'Copy CustomGPT JSON';
                                copyGptBtn.className = 'btn btn-secondary';
                                copyGptBtn.addEventListener('click', () => App.utils.copyToClipboard(gptJsonString, copyGptBtn));
                                gptButtonContainer.appendChild(copyGptBtn);

                                const backBtn = document.createElement('button');
                                backBtn.textContent = 'Back to Internal Format';
                                backBtn.className = 'btn btn-secondary';
                                backBtn.addEventListener('click', () => {
                                    gptView.style.display = 'none';
                                    originalView.style.display = 'block';
                                });
                                gptButtonContainer.appendChild(backBtn);
                                gptView.appendChild(gptButtonContainer);

                                const gptDetails = document.createElement('details');
                                gptDetails.open = true;
                                gptDetails.innerHTML = `<summary>Generated JSON Payload (OpenAI CustomGPT Format)</summary><pre>${gptJsonString}</pre>`;
                                gptView.appendChild(gptDetails);
                                responseEl.appendChild(gptView);

                                const exportBtn = document.createElement('button');
                                exportBtn.textContent = 'Export for CustomGPT';
                                exportBtn.className = 'btn btn-secondary';
                                exportBtn.addEventListener('click', () => {
                                    originalView.style.display = 'none';
                                    gptView.style.display = 'block';
                                });
                                originalButtonContainer.appendChild(exportBtn);

                            } catch (e) {
                                console.error("Error during CustomGPT conversion:", e);
                                const exportBtn = document.createElement('button');
                                exportBtn.textContent = 'Export Failed';
                                exportBtn.className = 'btn btn-secondary';
                                exportBtn.disabled = true;
                                exportBtn.title = `Error during CustomGPT conversion: ${e.message}`;
                                originalButtonContainer.appendChild(exportBtn);
                            }
                        }
                    },

                    setOAuthSuccessState() {
                        const statusEl = App.dom.qs.oauthStatusMsg;
                        statusEl.textContent = " Successfully authenticated via OAuth. Creating session...";
                        statusEl.style.color = 'var(--color-success)';

                        [App.dom.qs.apiKeyInput, App.dom.qs.explorerApiKeyInput].forEach(input => {
                            input.value = "Authenticated via OAuth";
                            input.readOnly = true;
                            input.style.cursor = "default";
                            input.style.fontStyle = "italic";
                        });
                        document.getElementById('auth-choice-bearer').checked = true;
                        document.getElementById('auth-bearer-view').style.display = 'block';
                        document.getElementById('auth-oauth-view').style.display = 'none';
                        App.dom.qs.oauthLoginBtn.style.display = 'none';
                        App.dom.qs.oauthLogoutBtn.style.display = 'inline-block';
                    },

                    resetApiKeyState(isAutomatic = false) {
                        [App.dom.qs.apiKeyInput, App.dom.qs.explorerApiKeyInput].forEach(input => {
                            input.value = "";
                            input.readOnly = false;
                            input.style.cursor = "text";
                            input.style.fontStyle = "normal";
                            input.type = 'password';
                        });
                        App.dom.qs.chatIdDisplay.style.display = 'none';
                        App.dom.qs.oauthLoginBtn.style.display = 'inline-block';
                        App.dom.qs.oauthLogoutBtn.style.display = 'none';
                        const statusEl = App.dom.qs.oauthStatusMsg;
                        if (isAutomatic) {
                            statusEl.textContent = "Endpoint changed. Please re-authenticate.";
                            statusEl.style.color = 'var(--color-text-muted)';
                        } else {
                            statusEl.textContent = "Logged out.";
                        }
                    },

                    scrollToStep(elementId) {
                        const element = document.getElementById(elementId);
                        if (element) {
                            element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    },

                    updateBearerTokenLink() {
                        const container = App.dom.qs.bearerTokenLinkContainer;
                        const mainLink = App.dom.qs.bearerTokenMainLink;
                        try {
                            const origin = new URL(App.state.endpointUrl).origin;
                            const tokenUrl = `${origin}/oauth/applications.vsp`;

                            container.innerHTML = `Need a token? <a href="${tokenUrl}" target="_blank" rel="noopener noreferrer">Get one here</a>.`;

                            if (mainLink) {
                                mainLink.href = tokenUrl;
                            }
                        } catch (e) {
                            container.innerHTML = 'Enter a valid Service Endpoint URL to get a token link.';
                            if (mainLink) {
                                mainLink.href = '#';
                            }
                        }
                    },

                    initializeApiKeyVisibilityToggle() {
                        const eyeIcon = `<svg viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>`;
                        const eyeOffIcon = `<svg viewBox="0 0 24 24"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>`;
                        const toggleButtons = document.querySelectorAll('.api-key-toggle-vis');
                        const apiKeyInputs = document.querySelectorAll('input[data-state-key="apiKey"], input[data-state-key="modelApiKeyOverride"]');

                        const updateIconsAndInputs = () => {
                            toggleButtons.forEach(btn => btn.innerHTML = App.state.isApiKeyVisible ? eyeIcon : eyeOffIcon);
                            apiKeyInputs.forEach(input => {
                                if (!input.readOnly) {
                                    input.type = App.state.isApiKeyVisible ? 'text' : 'password';
                                }
                            });
                            this.syncApiCards();
                        };

                        toggleButtons.forEach(btn => {
                            btn.addEventListener('click', () => {
                                App.state.isApiKeyVisible = !App.state.isApiKeyVisible;
                                updateIconsAndInputs();
                            });
                        });
                        updateIconsAndInputs();
                    },

                    initializeLinkableHeaders() {
                        const linkIconSvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>`;
                        document.querySelectorAll('main h2, main h3, .endpoint-header').forEach(header => {
                            if (!header.id) {
                                const cleanId = header.textContent.trim().toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
                                if (cleanId) header.id = cleanId;
                            }
                            if (header.id) {
                                const link = document.createElement('a');
                                link.href = `#${header.id}`;
                                link.className = 'copy-link-icon';
                                link.title = 'Copy link to this section';
                                link.innerHTML = linkIconSvg;
                                header.appendChild(link);
                            }
                        });

                        document.body.addEventListener('click', e => {
                            const linkIcon = e.target.closest('.copy-link-icon');
                            if (linkIcon) {
                                e.preventDefault();
                                const url = new URL(linkIcon.href, window.location.href).toString();
                                navigator.clipboard.writeText(url).then(() => {
                                    let tooltip = document.querySelector('.copy-tooltip');
                                    if (!tooltip) {
                                        tooltip = document.createElement('span');
                                        tooltip.className = 'copy-tooltip';
                                        tooltip.textContent = 'Copied!';
                                        document.body.appendChild(tooltip);
                                    }
                                    const rect = linkIcon.getBoundingClientRect();
                                    tooltip.style.top = `${rect.top + window.scrollY + rect.height / 2}px`;
                                    tooltip.style.left = `${rect.left + window.scrollX - 70}px`;
                                    tooltip.classList.add('visible');
                                    setTimeout(() => tooltip.classList.remove('visible'), 2000);
                                });
                            }
                        });
                    },

                    initializeFunctionBindingListener() {
                        const updateFunctions = (container) => {
                            const functions = Array.from(container.querySelectorAll('.function-item input:checked'))
                                .map(cb => ({ function: cb.value, title: cb.dataset.title }));
                            App.updateState('sessionFunctions', functions);

                            if (container.id === 'qs-function-selector-container') {
                                const responseEl = App.dom.qs.configResponseEl;
                                if (functions.length > 0) {
                                    const functionTitles = functions.map(f => `  - ${f.title}`).join('\n');
                                    responseEl.textContent = `Functions selected (click "Bind" to apply):\n${functionTitles}`;
                                    responseEl.className = 'response-viewer';
                                } else {
                                    responseEl.textContent = 'No functions are currently selected.';
                                    responseEl.className = 'response-viewer';
                                }
                            }
                        };
                        ['qs-function-selector-container', 'qs-agent-function-selector-container'].forEach(id => {
                            const container = document.getElementById(id);
                            if (container) {
                                container.addEventListener('change', e => {
                                    if (e.target.type === 'checkbox') updateFunctions(container);
                                });
                            }
                        });
                    },

                    initializeStep4Choice() {
                        const paths = {
                            functions: document.getElementById('path-functions'),
                            instantiate: document.getElementById('path-instantiate'),
                            create: document.getElementById('path-create'),
                            llms: document.getElementById('path-llms')
                        };
                        const step5Container = document.getElementById('qs-step-5-modify-session').closest('.timeline-item');
                        const step6Container = document.getElementById('qs-step-6-ask-question').closest('.timeline-item');


                        document.querySelector('.session-choice').addEventListener('change', (e) => {
                            const selectedValue = e.target.value;

                            if (selectedValue === 'instantiate' || selectedValue === 'llms') {
                                step5Container.style.display = 'none';
                                step6Container.style.display = 'none';
                            } else {
                                step5Container.style.display = 'block';
                                step6Container.style.display = 'block';
                            }

                            if (selectedValue !== 'instantiate' && App.state.isAgentSession) {
                                this.switchToAgentSelectionView();
                            }

                            Object.values(paths).forEach(p => p.style.display = 'none');
                            const selectedPath = paths[selectedValue];

                            if (selectedPath) {
                                selectedPath.style.display = 'block';
                                if (selectedValue === 'create') {
                                    const idInput = document.getElementById('qs-agent-id');
                                    if (!idInput.value) idInput.value = 'my-new-agent';
                                    const titleInput = document.getElementById('qs-agent-title');
                                    if (!titleInput.value) titleInput.value = 'Agent';
                                    const versionInput = document.getElementById('qs-agent-version');
                                    if (!versionInput.value) versionInput.value = '1.0.0';
                                    document.getElementById('qs-agent-creation-date').value = new Date().toISOString();
                                    const promptTextarea = document.getElementById('qs-agent-prompt');
                                    if (!promptTextarea.value) {
                                        promptTextarea.value = App.state.defaultAgentTemplate;
                                        promptTextarea.dispatchEvent(new Event('input'));
                                    }
                                } else if (selectedValue === 'llms') {
                                    App.handlers.handleListModels();
                                }
                            }
                        });
                    },

                    initializeMarkdownUploader() {
                        const dropZone = document.getElementById('markdown-drop-zone');
                        const fileInput = document.getElementById('markdown-file-input');
                        const promptTextarea = document.getElementById('qs-agent-prompt');
                        const readFileContent = (file) => {
                            if (file && (file.type === 'text/markdown' || file.type === 'text/plain' || file.name.endsWith('.md'))) {
                                const reader = new FileReader();
                                reader.onload = (e) => {
                                    promptTextarea.value = e.target.result;
                                    dropZone.classList.add('has-content');
                                };
                                reader.readAsText(file);
                            } else {
                                alert('Please upload a valid Markdown (.md) or text (.txt) file.');
                            }
                        };
                        promptTextarea.addEventListener('input', () => dropZone.classList.toggle('has-content', !!promptTextarea.value));
                        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('drag-over'); });
                        dropZone.addEventListener('dragenter', (e) => { e.preventDefault(); dropZone.classList.add('drag-over'); });
                        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
                        dropZone.addEventListener('drop', (e) => {
                            e.preventDefault();
                            dropZone.classList.remove('drag-over');
                            if (e.dataTransfer.files.length) readFileContent(e.dataTransfer.files[0]);
                        });
                        fileInput.addEventListener('change', (e) => { if (e.target.files.length) readFileContent(e.target.files[0]); });
                    },

                    initializeAuthMethodToggle() {
                        const bearerView = document.getElementById('auth-bearer-view');
                        const oauthView = document.getElementById('auth-oauth-view');
                        document.querySelector('.auth-choice').addEventListener('change', (e) => {
                            const isBearer = e.target.value === 'bearer';
                            bearerView.style.display = isBearer ? 'block' : 'none';
                            oauthView.style.display = isBearer ? 'none' : 'block';
                            App.updateState('authMethod', e.target.value);
                        });
                    }
                },

                utils: {
                    getSensibleDefault(schema, name) {
                        if (name === 'chat_id') return App.state.chatId || `your_chat_id`;
                        if (name === 'question') return App.state.question;
                        if (name === 'model') return App.state.model;
                        if (name === 'title') return App.state.title;
                        if (name === 'top_p') return App.state.top_p;
                        if (name === 'temperature') return App.state.temperature;
                        if (schema.type === 'integer' || schema.type === 'number') return 10;
                        if (schema.type === 'boolean') return true;
                        if (name.toLowerCase().includes('id')) return `your_${name.replace(/([A-Z])/g, '_$1').toLowerCase()}`;
                        return 'example_value';
                    },

                    generateBodyTemplate(schemaRef, operationId) {
                        const template = {};
                        const schemaName = schemaRef?.split('/').pop();
                        const schema = schemaName ? App.state.openApiSpec.components.schemas[schemaName] : null;

                        if (schema && schema.properties) {
                            const propertiesToExclude = ['alt_question', 'apiKey', 'call', 'fine_tune'];
                            for (const [prop, propSchema] of Object.entries(schema.properties)) {
                                if (!propertiesToExclude.includes(prop)) {
                                    template[prop] = this.getSensibleDefault(propSchema, prop);
                                }
                            }
                        }
                        return JSON.stringify(template, null, 2);
                    },

                    getEndpointData(endpointId) {
                        const card = document.getElementById(endpointId);
                        const path = card.querySelector('.endpoint-path').textContent;
                        const method = card.querySelector('.method-badge').textContent.toLowerCase();
                        const endpointSpec = App.state.openApiSpec.paths[path][method];
                        const requiresAuth = !!endpointSpec.security;

                        const params = { query: {}, header: {}, path: {} };
                        card.querySelectorAll('input[data-param-name]').forEach(input => {
                            if (input.value) params[input.dataset.paramIn][input.dataset.paramName] = input.value;
                        });

                        let body = null;
                        const bodyTextarea = card.querySelector('.request-body-input');
                        if (bodyTextarea?.value) {
                            try { body = JSON.parse(bodyTextarea.value); } catch (e) { body = {}; }
                        }

                        if (body) {
                            if (body.hasOwnProperty('apiKey') && App.state.modelApiKeyOverride) {
                                body.apiKey = App.state.modelApiKeyOverride;
                            }
                            if (body.hasOwnProperty('chat_id')) {
                                body.chat_id = document.getElementById('explorer-chat-id').value;
                            }
                        }

                        if (endpointSpec.operationId === 'chatCompletion' && App.state.sessionFunctions.length > 0) {
                            if (!body) body = {};
                            body.call = App.state.sessionFunctions.map(f => f.function);
                        }

                        return { path, method, requiresAuth, params, body };
                    },

                    generateCodeSnippet(language, endpointData) {
                        const { path, method, requiresAuth, params, body } = endpointData;

                        let sanitizedBody = null;
                        if (body) {
                            sanitizedBody = JSON.parse(JSON.stringify(body));
                            if (sanitizedBody.hasOwnProperty('apiKey') && sanitizedBody.apiKey) {
                                sanitizedBody.apiKey = '[...masked for security...]';
                            }
                        }

                        let fullUrl = `${App.state.endpointUrl}${path}`;
                        const queryParams = new URLSearchParams(params.query);
                        if (queryParams.toString()) fullUrl += `?${queryParams.toString()}`;

                        const headers = { 'Content-Type': 'application/json' };
                        if (requiresAuth) {
                            const bearerToken = App.state.isApiKeyVisible ? (App.state.apiKey || 'YOUR_API_KEY') : '[...masked for security...]';
                            headers['Authorization'] = `Bearer ${bearerToken}`;
                        }

                        switch (language) {
                            case 'curl':
                                let curlCmd = `curl -X ${method.toUpperCase()} "${fullUrl}" \\\n`;
                                for (const [key, value] of Object.entries(headers)) {
                                    curlCmd += `     -H "${key}: ${value}" \\\n`;
                                }
                                if (sanitizedBody) curlCmd += `     -d '${JSON.stringify(sanitizedBody, null, 2)}'`;
                                return curlCmd.replace(/ \\\n$/, '');
                            case 'javascript':
                                return `const url = "${fullUrl}";
const options = {
    method: '${method.toUpperCase()}',
    headers: ${JSON.stringify(headers, null, 4)}
};
${sanitizedBody ? `options.body = JSON.stringify(${JSON.stringify(sanitizedBody, null, 4)});` : ''}

fetch(url, options)
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('Error:', error));`;
                            case 'typescript':
                                const tsBody = sanitizedBody ? `    body: JSON.stringify(${JSON.stringify(sanitizedBody, null, 4)}),` : '';
                                return `async function makeApiCall(): Promise<void> {
    const url: string = "${fullUrl}";
    const options: RequestInit = {
        method: '${method.toUpperCase()}',
        headers: {
${Object.entries(headers).map(([key, value]) => `            '${key}': '${value}'`).join(',\n')}
        },
${tsBody ? `        ${tsBody.trim()}\n` : ''}    };

    try {
        const response: Response = await fetch(url, options);
        if (!response.ok) {
            throw new Error(\`HTTP error! status: \${response.status}\`);
        }
        const data: any = await response.json();
        console.log(data);
    } catch (error) {
        console.error('Error making API call:', error);
    }
}

makeApiCall();`;
                            case 'python':
                                return `import requests
import json

url = "${fullUrl}"
headers = ${JSON.stringify(headers, null, 4)}
${sanitizedBody ? `payload = ${JSON.stringify(sanitizedBody, null, 4)}` : 'payload = {}'}

response = requests.${method}(url, headers=headers${sanitizedBody ? ', json=payload' : ''})

print(response.json())`;
                            case 'java':
                                return `import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

public class ApiCall {
    public static void main(String[] args) throws Exception {
        HttpClient client = HttpClient.newHttpClient();
        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                .uri(URI.create("${fullUrl}"))
                .header("Content-Type", "application/json")
                ${requiresAuth ? `.header("Authorization", "Bearer ${App.state.isApiKeyVisible ? (App.state.apiKey || 'YOUR_API_KEY') : '[...masked for security...]'} ")` : ''};

        ${sanitizedBody ? `String requestBody = """
${JSON.stringify(sanitizedBody, null, 2)}
                """;
        requestBuilder.method("${method.toUpperCase()}", HttpRequest.BodyPublishers.ofString(requestBody));`
                                        : `requestBuilder.${method.toUpperCase()}();`}

        HttpRequest request = requestBuilder.build();
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

        System.out.println(response.body());
    }
}`;
                            case 'rust':
                                const rustBody = sanitizedBody ? `    let body: serde_json::Value = serde_json::from_str(r#"
${JSON.stringify(sanitizedBody, null, 2)}
"#)?;` : '';

                                const rustSend = sanitizedBody ? `        .json(&body)` : '';

                                return `// Add to Cargo.toml:
// reqwest = { version = "0.11", features = ["json"] }
// tokio = { version = "1", features = ["full"] }
// serde_json = "1.0"

use reqwest::{Client, header};
use serde_json::Value;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = Client::new();
    let url = "${fullUrl}";

    let mut headers = header::HeaderMap::new();
    headers.insert(header::CONTENT_TYPE, "application/json".parse().unwrap());
${requiresAuth ? `    headers.insert(header::AUTHORIZATION, "Bearer ${App.state.isApiKeyVisible ? (App.state.apiKey || "YOUR_API_KEY") : "[...masked for security...]"}".parse().unwrap());` : ''}

${rustBody}

    let response = client.${method}(url)
        .headers(headers)
${rustSend}
        .send()
        .await?;

    println!("Status: {}", response.status());
    
    let response_json: Value = response.json().await?;
    println!("Response:\\n{}", serde_json::to_string_pretty(&response_json)?);

    Ok(())
}`;
                        }
                        return '';
                    },

                    mergeOpenApiSpecs(specs) {
                        if (!specs || specs.length === 0) return null;
                        const baseSpec = JSON.parse(JSON.stringify(specs[0]));
                        for (let i = 1; i < specs.length; i++) {
                            const specToMerge = specs[i];
                            if (specToMerge.paths) Object.assign(baseSpec.paths, specToMerge.paths);
                            if (specToMerge.components) Object.assign(baseSpec.components, specToMerge.components);
                        }
                        return baseSpec;
                    },

                    extractFunctionsFromSpec(spec) {
                        const functions = [];
                        if (!spec || !spec.paths) return functions;
                        for (const [path, methods] of Object.entries(spec.paths)) {
                            for (const [method, details] of Object.entries(methods)) {
                                if (details.operationId) {
                                    functions.push({
                                        name: details.operationId,
                                        function: details.operationId,
                                        title: details.summary || details.description || details.operationId
                                    });
                                }
                            }
                        }
                        return functions;
                    },

                    copyToClipboard(text, button) {
                        navigator.clipboard.writeText(text).then(() => {
                            const originalText = button.textContent;
                            button.textContent = 'Copied!';
                            setTimeout(() => { button.textContent = originalText; }, 2000);
                        });
                    },

                    async discoverOAuthEndpoints(origin, statusEl) {
                        if (App.state.oauthEndpoints) {
                            return App.state.oauthEndpoints;
                        }
                        const discoveryUrl = `${origin}/.well-known/openid-configuration`;

                        const processResponse = async (response, isProxy = false) => {
                            let config;
                            try {
                                config = await response.json();
                            } catch (e) {
                                throw new Error("The server's discovery document is not valid JSON.");
                            }

                            if (!config.authorization_endpoint || !config.token_endpoint) {
                                throw new Error("The discovery document is valid but is missing required OAuth endpoint information.");
                            }

                            if (isProxy && statusEl) {
                                statusEl.textContent = "Discovery successful via proxy.";
                                statusEl.style.color = 'var(--color-success)';
                            }
                            return config;
                        };

                        try {
                            const response = await fetch(discoveryUrl);
                            if (response.ok) {
                                return await processResponse(response);
                            } else {
                                if (response.status === 404) {
                                    throw new Error(`Server returned 404 (Not Found). Please check if the Endpoint URL is correct and if it supports OpenID discovery.`);
                                } else if (response.status >= 500) {
                                    throw new Error(`The server experienced an internal error (Status: ${response.status}). Please try again later.`);
                                } else {
                                    throw new Error(`Could not fetch discovery document (HTTP Status: ${response.status})`);
                                }
                            }
                        } catch (error) {
                            if (error instanceof TypeError) {
                                if (statusEl) {
                                    statusEl.textContent = "Direct connection failed due to server's CORS policy. Retrying via proxy...";
                                    statusEl.style.color = 'var(--color-text-muted)';
                                }
                                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(discoveryUrl)}`;
                                try {
                                    const proxyResponse = await fetch(proxyUrl);
                                    if (proxyResponse.ok) {
                                        return await processResponse(proxyResponse, true);
                                    } else {
                                        if (proxyResponse.status === 404) {
                                            throw new Error(`Proxy request failed: Server returned 404 (Not Found). The Endpoint URL appears to be incorrect.`);
                                        } else {
                                            throw new Error(`Proxy request failed with HTTP Status: ${proxyResponse.status}`);
                                        }
                                    }
                                } catch (proxyError) {
                                    throw new Error(`Failed to connect via proxy. Please check your network connection. Details: ${proxyError.message}`);
                                }
                            }
                            throw error;
                        }
                    },

                    generateRandomString(length = 40) {
                        const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
                        let result = '';
                        const randomValues = new Uint8Array(length);
                        window.crypto.getRandomValues(randomValues);
                        for (let i = 0; i < length; i++) {
                            result += charset[randomValues[i] % charset.length];
                        }
                        return result;
                    },

                    async generatePkceChallenge() {
                        const verifier = this.generateRandomString(128);
                        const encoder = new TextEncoder();
                        const data = encoder.encode(verifier);
                        const digest = await window.crypto.subtle.digest('SHA-256', data);
                        const challenge = btoa(String.fromCharCode(...new Uint8Array(digest)))
                            .replace(/\+/g, '-')
                            .replace(/\//g, '_')
                            .replace(/=/g, '');
                        return { verifier, challenge };
                    },

                    clearOAuthSession() {
                        sessionStorage.removeItem('oauth_state_nonce');
                        sessionStorage.removeItem('oauth_pkce_verifier');
                        sessionStorage.removeItem('oauth_client_id');
                    },

                    transformMarkdownToAgentJson(markdownText, metadata) {
                        const encodeB64 = (str) => {
                            try { return btoa(unescape(encodeURIComponent(str))); }
                            catch (e) { return btoa(str); }
                        };
                        const escapeAngles = (s) => typeof s === 'string' ? s.replace(/</g, '\\u003C').replace(/>/g, '\\u003E') : s;

                        try {
                            const text = markdownText || '';
                            const lines = text.split(/\r?\n/);

                            const toCamel = (s) => {
                                if (!s) return '';
                                return s.trim()
                                    .replace(/[^\w\s&]+/g, '')
                                    .replace(/&/g, 'And')
                                    .split(/\s+/)
                                    .map((w, i) => i === 0 ? w.toLowerCase() : (w[0]?.toUpperCase() + w.slice(1)))
                                    .join('');
                            };

                            const normalizeValue = (v) => {
                                if (typeof v !== 'string') return v;
                                const t = v.trim();
                                if (/^(1|enabled|yes)$/i.test(t)) return true;
                                if (/^(0|not available|no|none)$/i.test(t)) return false;
                                return t;
                            };

                            const h1 = (text.match(/^\s*#\s*(.+)$/m) || [, null])[1];
                            const rootKey = (metadata && metadata.id) ? String(metadata.id) : (h1 ? toCamel(h1) : 'agent');
                            const root = { [rootKey]: Object.assign({}, metadata || {}) };
                            if (!root[rootKey].name) root[rootKey].name = h1 || metadata?.title || rootKey;

                            const contextStack = [{ level: 0, obj: root[rootKey] }];
                            const listParents = {};

                            let inFence = false, fenceMarker = '', fenceLang = '', fenceBuffer = [];
                            let inInlineSparql = false, inlineBuffer = [];

                            let multilineKey = null, multilineTarget = null, multilineBuf = [];

                            const commitMultiline = () => {
                                if (multilineKey && multilineTarget) {
                                    const full = multilineBuf.join('\n');
                                    if (full && full.length) {
                                        if (typeof multilineTarget[multilineKey] === 'string' && multilineTarget[multilineKey].length) {
                                            multilineTarget[multilineKey] = (multilineTarget[multilineKey] + '\n' + full).trim();
                                        } else {
                                            multilineTarget[multilineKey] = full;
                                        }
                                    }
                                }
                                multilineKey = null; multilineTarget = null; multilineBuf = [];
                            };

                            const closeInlineSparql = () => {
                                if (!inInlineSparql) return;
                                const codeText = inlineBuffer.join('\n');
                                const b64 = encodeB64(codeText);
                                const ctx = contextStack[contextStack.length - 1];
                                if (Array.isArray(ctx.obj) && ctx.obj.length > 0 && typeof ctx.obj[ctx.obj.length - 1] === 'object') {
                                    const lastObj = ctx.obj[ctx.obj.length - 1];
                                    lastObj.query = escapeAngles(codeText);
                                    lastObj.query_b64 = b64;
                                } else if (multilineKey && multilineTarget) {
                                    multilineBuf.push(codeText);
                                    commitMultiline();
                                } else if (typeof ctx.obj === 'object') {
                                    if (!ctx.obj._inlineSparql) ctx.obj._inlineSparql = [];
                                    ctx.obj._inlineSparql.push({ text: escapeAngles(codeText), b64 });
                                }
                                inInlineSparql = false; inlineBuffer = [];
                            };

                            const current = () => contextStack[contextStack.length - 1];

                            for (const rawLine of lines) {
                                const line = rawLine;
                                const trimmed = line.trim();

                                const fenceMatch = trimmed.match(/^(`{3,}|~{3,})(.*)$/);
                                if (fenceMatch) {
                                    if (inInlineSparql) closeInlineSparql();
                                    commitMultiline();
                                    const marker = fenceMatch[1], info = fenceMatch[2].trim();
                                    if (!inFence) {
                                        inFence = true; fenceMarker = marker; fenceLang = info; fenceBuffer = [];
                                    } else if (marker === fenceMarker) {
                                        inFence = false;
                                        const codeText = fenceBuffer.join('\n');
                                        const b64 = encodeB64(codeText);
                                        const looksLikeSparql = /^\s*SPARQL\b/i.test(codeText) || /\bPREFIX\b/i.test(codeText) || /\bBASE\b/i.test(codeText) || fenceLang.includes('sparql');

                                        const ctx = current();
                                        if (Array.isArray(ctx.obj) && ctx.obj.length > 0 && typeof ctx.obj[ctx.obj.length - 1] === 'object') {
                                            const lastObj = ctx.obj[ctx.obj.length - 1];
                                            if (looksLikeSparql) {
                                                lastObj.query = escapeAngles(codeText);
                                                lastObj.query_b64 = b64;
                                            } else {
                                                if (!lastObj._codeBlocks) lastObj._codeBlocks = [];
                                                lastObj._codeBlocks.push({ lang: fenceLang || null, text: escapeAngles(codeText), b64 });
                                            }
                                        } else if (multilineKey && multilineTarget) {
                                            multilineBuf.push(codeText);
                                            commitMultiline();
                                        } else if (typeof ctx.obj === 'object') {
                                            if (!ctx.obj._codeBlocks) ctx.obj._codeBlocks = [];
                                            ctx.obj._codeBlocks.push({ lang: fenceLang || null, text: escapeAngles(codeText), b64 });
                                        }
                                        fenceMarker = ''; fenceLang = ''; fenceBuffer = [];
                                    } else {
                                        fenceBuffer.push(line);
                                    }
                                    continue;
                                }
                                if (inFence) { fenceBuffer.push(line); continue; }

                                if (!inInlineSparql && trimmed.match(/^(SPARQL\b|PREFIX\b|BASE\b|@prefix\b)/i)) {
                                    commitMultiline();
                                    inInlineSparql = true; inlineBuffer = [line];
                                    continue;
                                }
                                if (inInlineSparql) {
                                    if (!trimmed || trimmed.match(/^(#{1,6})\s+/) || /^[-*_]{3,}\s*$/.test(trimmed) || /^\s*[-*]\s+/.test(line) || /^\s*\d+\.\s+/.test(trimmed)) {
                                        closeInlineSparql();
                                    } else {
                                        inlineBuffer.push(line);
                                        continue;
                                    }
                                }

                                if (!trimmed || /^[-*_]{3,}\s*$/.test(trimmed) || /^\s*!?\[/.test(trimmed)) { commitMultiline(); continue; }

                                const hMatch = trimmed.match(/^(#{1,6})\s+(.*)$/);
                                if (hMatch) {
                                    commitMultiline();
                                    const level = hMatch[1].length;
                                    const title = hMatch[2].replace(/\*\*/g, '').trim();
                                    const key = toCamel(title);
                                    while (contextStack.length > 0 && contextStack[contextStack.length - 1].level >= level) contextStack.pop();
                                    const parent = contextStack[contextStack.length - 1].obj;
                                    if (!Object.prototype.hasOwnProperty.call(parent, key)) parent[key] = {};
                                    else if (Array.isArray(parent[key])) parent[key] = { items: parent[key] };
                                    contextStack.push({ level, obj: parent[key], key });
                                    for (const k in listParents) delete listParents[k];
                                    continue;
                                }

                                const kv = trimmed.match(/^\s*[-*]?\s*\*\*(.+?)\*\*\s*:\s*(.*)$/);
                                if (kv) {
                                    commitMultiline();
                                    const k = toCamel(kv[1].trim());
                                    const v = kv[2] || '';
                                    let target = current().obj;
                                    if (Array.isArray(target)) {
                                        const obj = {}; obj[k] = normalizeValue(v); target.push(obj);
                                        multilineTarget = obj; multilineKey = k; multilineBuf = [v];
                                    } else if (typeof target === 'object') {
                                        if (!target[k] || target[k] === '') target[k] = normalizeValue(v);
                                        multilineTarget = target; multilineKey = k; multilineBuf = [v];
                                    }
                                    continue;
                                }

                                const bullet = rawLine.match(/^(\s*)[-*]\s+(.*)$/);
                                if (bullet) {
                                    commitMultiline();
                                    const indent = bullet[1].length;
                                    const content = bullet[2].trim();
                                    const ctxObj = current().obj;
                                    const findListParent = (ind) => {
                                        let candidate = ind;
                                        while (candidate >= 0) {
                                            if (listParents[candidate]) return listParents[candidate];
                                            candidate -= 1;
                                        }
                                        return ctxObj;
                                    };

                                    const boldTitle = content.match(/^\*\*(.+?)\*\*\s*:?$/);
                                    const boldKv = content.match(/^\*\*(.+?)\*\*\s*:\s*(.*)$/);

                                    if (boldTitle) {
                                        const title = boldTitle[1].trim();
                                        const key = toCamel(title);
                                        const parentForThis = findListParent(indent) || ctxObj;
                                        if (!parentForThis || typeof parentForThis !== 'object' || Array.isArray(parentForThis)) {
                                            if (typeof parentForThis === 'object') { parentForThis.list = parentForThis.list || []; parentForThis.list.push(title); listParents[indent] = parentForThis; }
                                        } else {
                                            if (!Object.prototype.hasOwnProperty.call(parentForThis, key) || typeof parentForThis[key] !== 'object') parentForThis[key] = {};
                                            listParents[indent + 1] = parentForThis[key];
                                            listParents[indent] = parentForThis[key];
                                        }
                                        continue;
                                    } else if (boldKv) {
                                        const subK = toCamel(boldKv[1].trim());
                                        const subV = boldKv[2] || '';
                                        const attachTo = findListParent(indent) || ctxObj;
                                        if (attachTo && typeof attachTo === 'object' && !Array.isArray(attachTo)) {
                                            attachTo[subK] = normalizeValue(subV);
                                            multilineTarget = attachTo; multilineKey = subK; multilineBuf = [subV];
                                        } else {
                                            if (!ctxObj.list) ctxObj.list = [];
                                            const o = {}; o[subK] = normalizeValue(subV); ctxObj.list.push(o);
                                            multilineTarget = o; multilineKey = subK; multilineBuf = [subV];
                                        }
                                        continue;
                                    } else {
                                        const attachTo = findListParent(indent) || ctxObj;
                                        if (Array.isArray(attachTo)) attachTo.push(content);
                                        else if (typeof attachTo === 'object') { if (!attachTo.list) attachTo.list = []; attachTo.list.push(content); }
                                        else { if (!ctxObj.list) ctxObj.list = []; ctxObj.list.push(content); }
                                        continue;
                                    }
                                }

                                const numMatch = trimmed.match(/^\s*\d+\.\s+(.*)$/);
                                if (numMatch) {
                                    commitMultiline();
                                    const txt = numMatch[1].trim();
                                    const curr = current().obj;
                                    if (Array.isArray(curr)) curr.push(txt);
                                    else { if (!curr.steps) curr.steps = []; curr.steps.push(txt); }
                                    continue;
                                }

                                if (multilineKey && multilineTarget) {
                                    multilineBuf.push(line);
                                    continue;
                                }

                                const curr = current().obj;
                                if (typeof curr === 'object' && !Array.isArray(curr) && trimmed) {
                                    curr.description = ((curr.description || '') + (curr.description ? '\n' : '') + trimmed).trim();
                                }
                            }

                            if (inInlineSparql) closeInlineSparql();
                            commitMultiline();

                            const agentData = {};
                            const originalRoot = root[rootKey];

                            if (originalRoot.title) {
                                agentData.name = originalRoot.title;
                            } else if (originalRoot.name) {
                                agentData.name = originalRoot.name;
                            }
                            if (originalRoot.version) agentData.version = originalRoot.version;

                            if (originalRoot.features || originalRoot.virtuosoSupportAgent?.features) {
                                const featuresSource = originalRoot.features || originalRoot.virtuosoSupportAgent?.features;
                                agentData.features = {};

                                Object.keys(featuresSource).forEach(key => {
                                    if (key !== 'functions') {
                                        agentData.features[key] = featuresSource[key];
                                    }
                                });
                            }

                            let functionsData = null;
                            if (originalRoot.functions) {
                                functionsData = originalRoot.functions;
                            } else if (originalRoot.features?.functions) {
                                functionsData = originalRoot.features.functions;
                            } else if (originalRoot.virtuosoSupportAgent?.features?.functions) {
                                functionsData = originalRoot.virtuosoSupportAgent.features.functions;
                            }

                            let markdownFunctions = [];
                            if (functionsData && functionsData.list && Array.isArray(functionsData.list)) {
                                const transformedMarkdownFunctions = functionsData.list.map(item => {
                                    if (typeof item === 'string') {
                                        const cleanName = item.replace(/`/g, '').trim();
                                        return { name: cleanName };
                                    } else if (typeof item === 'object' && !item.name && !item.function) {
                                        return { name: String(item) };
                                    }
                                    return item;
                                });
                                markdownFunctions = transformedMarkdownFunctions;
                            }

                            if (!agentData.features) agentData.features = {};
                            agentData.features.functions = {};

                            if (functionsData && functionsData.description) {
                                agentData.features.functions.description = functionsData.description;
                            }

                            if (metadata && Array.isArray(metadata.functions) && metadata.functions.length) {
                                const transformedFunctions = metadata.functions.map(f => {
                                    const result = {};

                                    if (f.function) {
                                        result.name = f.function;
                                    } else if (f.name) {
                                        result.name = f.name;
                                    } else {
                                        result.name = typeof f === 'string' ? f : String(f);
                                    }

                                    Object.keys(f).forEach(key => {
                                        if (key !== 'function' && key !== 'name') {
                                            result[key] = f[key];
                                        }
                                    });

                                    return result;
                                });

                                agentData.features.functions.list = transformedFunctions;
                            } else if (markdownFunctions.length > 0) {
                                agentData.features.functions.list = markdownFunctions;
                            } else if (functionsData && functionsData.list) {
                                agentData.features.functions.list = functionsData.list;
                            }

                            ['commands', 'rules', 'preferences', 'formats', 'initialization', 'queryProcessingFeatures', 'predefinedPrompts', 'predefinedQueryTemplates', 'fallbackStrategies'].forEach(section => {
                                if (originalRoot[section]) {
                                    agentData[section] = originalRoot[section];
                                }
                            });

                            Object.keys(originalRoot).forEach(key => {
                                if (!['name', 'version', 'features', 'functions', 'commands', 'rules', 'preferences', 'formats', 'initialization', 'queryProcessingFeatures', 'predefinedPrompts', 'predefinedQueryTemplates', 'fallbackStrategies', 'virtuosoSupportAgent'].includes(key)) {
                                    agentData[key] = originalRoot[key];
                                }
                            });

                            return { agent: agentData };

                        } catch (err) {
                            console.error('transformMarkdownToAgentJson error:', err);
                            throw err;
                        }
                    },

                    transformMarkdownToOpenAIJson(markdownText, metadata) {
                        try {
                            const lines = markdownText.split('\n');
                            const json = { openai: { schema_version: '1.0.0', name: metadata.title || 'Custom AI Assistant', description: '', version: metadata.version || '1.0.0', instructions: '', capabilities: {}, query_processing: { predefined_skills: {}, predefined_prompts: [], functions: [] }, commands: [], rules: [], preferences: {}, formats: {}, initialization: {} } };
                            const openai = json.openai;
                            const baseDescription = (markdownText.match(/^\*\*Description:\*\*\s*(.*)/im) || [])[1]?.trim() || 'Custom AI Assistant';
                            openai.description = `${baseDescription} (ID: ${metadata.id}, Created: ${metadata.creationDate})`;
                            let currentH3 = '', currentH4 = '', currentSkill = null, currentPrompt = null, inCodeBlock = false, codeBlockContent = '';
                            for (const line of lines) {
                                const trimmed = line.trim(); if (!trimmed) continue;
                                if (trimmed.startsWith('```')) {
                                    inCodeBlock = !inCodeBlock;
                                    if (!inCodeBlock && currentPrompt && codeBlockContent) {
                                        if (currentPrompt.steps?.length) currentPrompt.steps[currentPrompt.steps.length - 1].query = codeBlockContent.trim();
                                        else if (!currentPrompt.response) currentPrompt.response = codeBlockContent.trim();
                                        codeBlockContent = '';
                                    }
                                    continue;
                                }
                                if (inCodeBlock) { codeBlockContent += line + '\n'; continue; }
                                const h3Match = trimmed.match(/^###\s+(.*)/);
                                if (h3Match) { currentH3 = h3Match[1].toLowerCase().replace(/\s+/g, '_'); currentH4 = ''; currentSkill = null; currentPrompt = null; if (currentH3 === 'capabilities') openai.capabilities = {}; continue; }
                                const h4Match = trimmed.match(/^####\s+(.*)/);
                                if (h4Match) {
                                    currentH4 = h4Match[1].toLowerCase().replace(/\s+/g, '_');
                                    if (currentH3 === 'capabilities') openai.capabilities[currentH4] = {};
                                    else if (currentH3 === 'query_processing' && !['predefined_skills', 'predefined_prompts', 'functions'].includes(currentH4)) openai.query_processing[currentH4] = {};
                                    continue;
                                }
                                switch (currentH3) {
                                    case 'rules': if (trimmed.startsWith('- ')) openai.rules.push(trimmed.substring(2)); break;
                                    case 'preferences': case 'formats': case 'initialization': { const m = trimmed.match(/^- \*\*(.*?):\*\*\s*(.*)/); if (m) openai[currentH3][m[1].toLowerCase().replace(/\s+/g, '_')] = m[2].trim(); break; }
                                    case 'commands': { const m = trimmed.match(/^- \*\*(.*?):\*\*\s*`([^`]+)`\s*-\s*(.*)/); if (m) openai.commands.push({ prefix: m[2], name: m[1].toLowerCase(), description: m[3] }); break; }
                                    case 'capabilities': { const m = trimmed.match(/^- \*\*(.*?):\*\*\s*(.*)/); if (m && currentH4) openai.capabilities[currentH4][m[1].toLowerCase().replace(/\s+/g, '_')] = { enabled: true, description: m[2].trim() }; break; }
                                    case 'query_processing':
                                        if (currentH4 === 'functions') { const m = trimmed.match(/^- \*\*(.*?):\*\*\s*(.*)/); if (m) openai.query_processing.functions.push({ name: m[1], description: m[2] }); }
                                        else if (currentH4 === 'predefined_skills') {
                                            const skillMatch = trimmed.match(/^- \*\*(.*?):\*\*/), numMatch = trimmed.match(/^\s*\d+\.\s+(.*)/);
                                            if (skillMatch) { currentSkill = skillMatch[1].toLowerCase().replace(/\s+/g, '_'); openai.query_processing.predefined_skills[currentSkill] = { rules: [], example_workflow: [] }; }
                                            else if (numMatch && currentSkill) {
                                                if (trimmed.includes('Example Workflow')) openai.query_processing.predefined_skills[currentSkill].example_workflow.push(numMatch[1]);
                                                else openai.query_processing.predefined_skills[currentSkill].rules.push({ step: numMatch[1], description: numMatch[1] });
                                            }
                                        } else if (currentH4 === 'predefined_prompts') {
                                            const typeMatch = trimmed.match(/^- (.*)/), stepMatch = trimmed.match(/^\s*\d+\.\s+(.*)/);
                                            if (typeMatch && !stepMatch) { currentPrompt = { type: typeMatch[1], steps: [] }; openai.query_processing.predefined_prompts.push(currentPrompt); }
                                            else if (stepMatch && currentPrompt) currentPrompt.steps.push({ step: currentPrompt.steps.length + 1, description: stepMatch[1] });
                                            else {
                                                const hintMatch = trimmed.match(/^- \*\*Hint:\*\*\s*(.*)/), promptMatch = trimmed.match(/^- \*\*Prompt:\*\*\s*(.*)/), queryMatch = trimmed.match(/^- \*\*Query:\*\*\s*`(.*)`/), responseMatch = trimmed.match(/^- \*\*Response:\*\*\s*(.*)/);
                                                if (hintMatch) currentPrompt.hint = hintMatch[1]; else if (promptMatch) currentPrompt.prompt = promptMatch[1]; else if (queryMatch) currentPrompt.query = queryMatch[1]; else if (responseMatch) currentPrompt.response = responseMatch[1];
                                            }
                                        } else if (currentH4) {
                                            const match = trimmed.match(/^- \*\*(.*?):\*\*\s*(.*)/), numMatch = trimmed.match(/^\s*\d+\.\s+(.*)/);
                                            if (match) openai.query_processing[currentH4][match[1].toLowerCase().replace(/\s+/g, '_')] = match[2];
                                            else if (numMatch) { if (!openai.query_processing[currentH4].steps) openai.query_processing[currentH4].steps = []; openai.query_processing[currentH4].steps.push(numMatch[1]); }
                                        }
                                        break;
                                    case 'initialization':
                                        if (!openai.initialization.greeting) {
                                            openai.initialization.greeting = `Hello! I'm ${metadata.title}, here to assist...`;
                                            openai.initialization.configuration = 'If preferences are invalid, guide the user through configuration.';
                                            openai.initialization.response_adjustment = 'Adjust responses based on user interactions.';
                                        }
                                        break;
                                }
                            }
                            return json;
                        } catch (error) { console.error('Error parsing Markdown to OpenAI JSON:', error); throw error; }
                    }
                }
            };

            App.init();
        });
    </script>
</body>

</html>
